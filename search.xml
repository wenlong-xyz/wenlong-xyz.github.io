<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>More Effective CSharp Notes</title>
      <link href="/2018/12/16/MoreEffectiveCSharp/"/>
      <url>/2018/12/16/MoreEffectiveCSharp/</url>
      
        <content type="html"><![CDATA[<p>&lt;<more effective="" c#="">&gt;笔记</more></p><h1 id="Working-with-Data-Types"><a href="#Working-with-Data-Types" class="headerlink" title="Working with Data Types"></a>Working with Data Types</h1><h2 id="Item-9-Equality"><a href="#Item-9-Equality" class="headerlink" title="Item 9: Equality"></a>Item 9: Equality</h2><ol><li><code>public static bool ReferenceEquals(object left, object right);</code><ul><li>Never redefine</li><li>Return true: same reference identity</li><li>Specially, return false when compare two value type variable(due to boxing)</li></ul></li><li><code>public static bool Equals(object left, object right);</code><ul><li>Never redefine</li><li>Call <code>ReferenceEquals</code> and instance <code>Equals()</code> to comapre two object instances</li></ul></li><li><p><code>public virtual bool Equals(object right);</code></p><ul><li>Equality<ul><li>reflexive: a == a</li><li>symmetric: a == b <--> b == a</--></li><li>transitive: a == b, b == c –&gt; a == c</li></ul></li><li>Default<ul><li>Reference type: same with <code>Object.ReferenceEquals()</code></li><li>Value type: have been override by <code>System.ValueType</code>, but we should create an override of <code>ValueType.Equals()</code> when we create a value type.</li></ul></li><li>How to override<ul><li>Impliment <code>IEquatable&lt;T&gt;</code></li><li>Impliment <code>GetHashCode()</code><ul><li>Equal objects must produce equal hash codes</li><li>Hash code must be object invariants</li><li>Must produce an even distribution to be efficient</li></ul></li><li>Standard pattern<figure class="highlight cs"><table><tr><td class="code"><pre><span class="line">public class Foo : IEquatable&lt;Foo&gt;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">override</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params"><span class="keyword">object</span> right</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Check null:</span></span><br><span class="line">        <span class="comment">// This reference is never null in C# methods</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">object</span>.ReferenceEquals(right, <span class="literal">null</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">object</span>.ReferenceEquals(<span class="keyword">this</span>, right))</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// To handle inheritance hierarchy problem</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.GetType() != right.GetType())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Compare this type's contents here:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.Equals(right <span class="keyword">as</span> Foo);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// IEquatable&lt;Foo&gt; Members</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">bool</span> <span class="title">Equals</span>(<span class="params">Foo other</span>)</span></span><br><span class="line"><span class="function"></span>    &#123;</span><br><span class="line">        <span class="comment">// Elided: this.x == other.x &amp;&amp; this.y == other.y, etc.</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p><code>public static bool operator ==(MyClass left, MyClass right);</code></p><ul><li>Redefine for value type, not reference type</li></ul></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>C# Ramp Up</title>
      <link href="/2018/05/01/CSharpRampUp/"/>
      <url>/2018/05/01/CSharpRampUp/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;因为之前有Java基础，在学习C#的时候，就容易了许多。本文会记录一些学习和使用C#过程中所遇到的一些问题。持续更新~</p><ul><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/classes-and-structs/access-modifiers" target="_blank" rel="noopener">Access Modifiers</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/types" target="_blank" rel="noopener">Value types and Reference types</a></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/collections" target="_blank" rel="noopener">容器类 Collections</a></li><li><strong>Struct vs Class</strong><ul><li>主要的区别在于<code>Reference type</code> 和 <code>Value type</code> 的区别, <strong>Struct is value type and Class is Reference type.</strong></li><li>细节可以参考 <a href="https://docs.microsoft.com/en-us/dotnet/standard/design-guidelines/choosing-between-class-and-struct" target="_blank" rel="noopener">Choosing Between Class and Struct</a></li></ul></li><li><strong>yield</strong><ul><li><code>yield return</code> 和 <code>yield break</code>, 利用状态机保存迭代状态, <code>yield return</code>返回一次迭代结果, <code>yield break</code>退出迭代</li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/yield" target="_blank" rel="noopener">yield Reference</a></li></ul></li><li><strong>Nullable Types</strong><ul><li>int?</li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/nullable-types/" target="_blank" rel="noopener">Nullable Types</a></li></ul></li><li><p><strong>异步编程（Asynchronous Programming）</strong></p><ul><li>基本使用<ul><li>CPU-bound: Prefer multithread</li><li>IO-bound: Prefer <code>async</code> and <code>await</code></li><li><a href="https://docs.microsoft.com/en-us/dotnet/csharp/programming-guide/concepts/async/" target="_blank" rel="noopener">Reference</a></li></ul></li><li>深入理解<ul><li>简单说来，<code>async</code> 和 <code>await</code>两个关键字并不会创建新线程，而是以状态机的形式保存code执行状态，并释放控制权（返回Task对象，用于后续管理），以同步的代码风格实现异步的执行逻辑。</li><li>推荐阅读：<a href="https://blogs.msdn.microsoft.com/seteplia/2017/11/30/dissecting-the-async-methods-in-c/" target="_blank" rel="noopener">Dissecting the async methods in C#</a></li></ul></li></ul></li><li><p><strong>并发编程（Parallel Programming）</strong></p></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C# </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>LaTeX 学习笔记</title>
      <link href="/2017/06/14/latex-start/"/>
      <url>/2017/06/14/latex-start/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;上周末快速学习了一下LaTeX，在这里记录一下。本文主要内容包括我在写论文的过程中从安装软件到最后生成PDF一路碰到问题与我找到的解决方案，不以探究LaTeX内部原理为导向，仅是为了实现想要的展示效果。<br>&emsp;&emsp;先说一下LaTeX的用途。LaTeX可以和Word对比，像word一样，它可以进行文字处理：文字编辑、图文混排等。在论文写作中，通过LaTeX的模板，可以快速排版，得到很好地展示效果，因此LaTeX受到很多写作者的喜爱，也有挺多人用它制作简历。区别于Word的图形化操作，LaTeX最大的特点就是“程序”化的编辑方式，所有的格式都可以以“代码”的方式规定，脱离鼠标的拖拽，用过Markdown的同学可能会有种熟悉的感觉。总之，论文写作，用LaTeX，挺好。</p><h1 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h1><p>&emsp;&emsp;我安装的是CTeX套装，其中自带WinEdt等编辑器。这里要说明一点：<strong>现在的CTeX 安装器有个Bug，安装过程中会把本机的环境变量Path覆盖掉，你没看错，是覆盖，不是追加，所以我现在电脑还残废着。安装前先备份一下，安完再改回去就好了。</strong><a href="http://www.ctex.org/CTeXDownload" target="_blank" rel="noopener">下载地址</a></p><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>&emsp;&emsp;由于我的论文格式要求是LNCS Format，所以以下内容会为LNCS Format为例说明使用过程，其他格式同理。</p><h2 id="模板下载"><a href="#模板下载" class="headerlink" title="模板下载"></a>模板下载</h2><p>&emsp;&emsp;<a href="https://www.springer.com/gp/computer-science/lncs/conference-proceedings-guidelines" target="_blank" rel="noopener">LNCS Format下载地址</a> ，我选的是“CS Proceedings and other multi-author volumes - using LaTeX2e”模板（官方也有提供word模板）。下载后发现文件里没有<code>.tex</code>文件（LaTeX的编辑文件），我是把<code>llncs.dem</code>直接改成了<code>llncs.tex</code>，应该有其他正确的打开方式吧，anyway，这样就可以编写了，先跑一下看看效果。我使用的WinEdt编辑器，打开<code>llncs.tex</code>后，点击PDFTeXify(编译器器的一种，我在后边也一直用这个，每个编译器具体区别可以自行Google)，就可以自动生成pdf并打开。<br><img src="winedt.PNG" alt=""><br>哈哈，这样hello world已经成功了，下边就开始了代码搬运工的工作。LNCS选手建议自习阅读模板里的<code>llncsdoc.pdf</code></p><h2 id="基本框框"><a href="#基本框框" class="headerlink" title="基本框框"></a>基本框框</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\documentclass[oribibl]&#123;llncs&#125;    // 引用模板格式，llncs为LNCS模板提供，其他模板相应更换</span><br><span class="line"></span><br><span class="line">\usepackage&#123;xxx&#125;   // 引用package，使用其中提供各种命令</span><br><span class="line"></span><br><span class="line">% 以下是部分常用的package, 后边的内容会用到其中的一些package，不再特别说明</span><br><span class="line">\usepackage&#123;graphicx&#125;</span><br><span class="line">\usepackage&#123;amsfonts&#125;</span><br><span class="line">\usepackage&#123;verbatim&#125;</span><br><span class="line">\usepackage[titlenumbered,ruled]&#123;algorithm2e&#125;</span><br><span class="line">\usepackage&#123;subfigure&#125;</span><br><span class="line">\usepackage&#123;caption&#125;</span><br><span class="line">\usepackage&#123;cite&#125;</span><br><span class="line">\usepackage&#123;url&#125;</span><br><span class="line">\usepackage&#123;float&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">\begin&#123;document&#125;  // 开始</span><br><span class="line">\section&#123;s1&#125;      // 章节2</span><br><span class="line">\section&#123;s2&#125;      // 章节2</span><br><span class="line">\end&#123;document&#125;    // 结束</span><br></pre></td></tr></table></figure><p><strong>注：上边列的package和后边的图表、引用等都有对应，但本文不做特别说明，因为我也忘了。指令错误，可以自动Google缺失包</strong></p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><h3 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h3><p>为方便起见，我使用了<code>\bibliography</code>命令，将参考文献单列到一个额外的<code>cited.bib</code>文件里。具体使用说明如下：<br><code>tex</code>文件里添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 设置引用style</span><br><span class="line">\bibliographystyle&#123;splncs&#125;</span><br><span class="line"></span><br><span class="line">% 为生成pdf添加reference书签</span><br><span class="line">\addcontentsline&#123;toc&#125;&#123;section&#125;&#123;\refname&#125;</span><br><span class="line"></span><br><span class="line">% 引入参考文献文件，cited对应到bib文件名</span><br><span class="line">\bibliography&#123;cited&#125;</span><br><span class="line"></span><br><span class="line">% 显示全部参考文献，即使文中没有明确引用位置</span><br><span class="line">\nocite&#123;*&#125;</span><br></pre></td></tr></table></figure></p><p><code>bib</code>文件里添加：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">% 示例，可以通过谷歌学术-引用-BibTeX自动生成</span><br><span class="line">@book&#123;citelabel, % 引用标签</span><br><span class="line">  title=&#123;Participant observation&#125;,</span><br><span class="line">  author=&#123;Spradley, James P&#125;,</span><br><span class="line">  year=&#123;2016&#125;,</span><br><span class="line">  publisher=&#123;Waveland Press&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>具体引用的地方只要添加<code>\cite{citelabel}</code>就可以了，其中<code>citelabel</code>为上面提到的引用标签，可以人为自定义。</p><h3 id="图片，表格，章节引用"><a href="#图片，表格，章节引用" class="headerlink" title="图片，表格，章节引用"></a>图片，表格，章节引用</h3><p>在图片、表格、章节中定义 <code>label</code>，然后使用时直接引用即可<code>~\ref{sec:overview}</code>, 比如：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\section&#123;System Overview and Problem Formulation&#125; \label&#123;sec:overview&#125;</span><br></pre></td></tr></table></figure></p><p>图片，表格，会在下边有更详细的说明</p><h2 id="图表"><a href="#图表" class="headerlink" title="图表"></a>图表</h2><h3 id="图片"><a href="#图片" class="headerlink" title="图片"></a>图片</h3><p>我使用的图片来源有Visio，Excel，网上介绍的LaTeX教程中，打过建议使用<code>.eps</code>格式的文件，但我在使用时，导入出了问题，没有细查。最终使用的所有图片均为pdf格式，一个图片一个pdf。详细说明如下：</p><ol><li>Visio转pdf: 文件-打印（打印机选Adobe PDF(其他pdf软件同理)），打印当前页（一张图片一张图片转）。</li><li>Excel图标转pdf，选择图标（如折线图）- 文件-打印(打印机选Adobe PDF)</li><li>pdf修剪，裁除白边。我使用的软件是Adobe Acrobat Pro（其他软件同理），打开文件-工具-设置页面框-勾选删除白边距-确定。</li></ol><p>经过这几步，这样图片也就变成了我们想要的样子。LaTeX使用代码如下：<br>单张图片：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;</span><br><span class="line">\centering  % 居中</span><br><span class="line">\includegraphics[height=3.8cm]&#123;images/Fig1&#125;  % 相对路径，可以自行修改</span><br><span class="line">\caption&#123;图片标题&#125;</span><br><span class="line">\label&#123;figlabel&#125;  % 引用处使用</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure></p><p>两张图片，一行显示：<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;figure&#125;</span><br><span class="line">\centering</span><br><span class="line">\begin&#123;minipage&#125;&#123;.38\textwidth&#125;  % 通过调整.38数字，控制图片大小</span><br><span class="line">  \centering</span><br><span class="line">  \includegraphics[width=1\linewidth]&#123;images/Fig1&#125;</span><br><span class="line">  \captionof&#123;figure&#125;&#123;Fig1&#125;</span><br><span class="line">  \label&#123;fig1&#125;</span><br><span class="line">\end&#123;minipage&#125;%</span><br><span class="line">\ \ \ % 简单的使用空格控制间距</span><br><span class="line">\begin&#123;minipage&#125;&#123;.58\textwidth&#125;</span><br><span class="line">  \centering</span><br><span class="line">  \includegraphics[width=1\linewidth]&#123;images/Fig2&#125;</span><br><span class="line">  \captionof&#123;figure&#125;&#123;Fig1&#125;</span><br><span class="line">  \label&#123;fig2&#125;</span><br><span class="line">\end&#123;minipage&#125;</span><br><span class="line">\end&#123;figure&#125;</span><br></pre></td></tr></table></figure></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p>和markdown一样，表格写起来比较费劲<br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;table&#125;</span><br><span class="line">\caption&#123;table&#125;</span><br><span class="line">\label&#123;table:table1&#125;</span><br><span class="line">\begin&#123;center&#125;</span><br><span class="line">\begin&#123;tabular&#125;&#123;c@&#123;\quad&#125;|@&#123;\quad&#125;c&#125;</span><br><span class="line">\hline</span><br><span class="line"> Name   &amp; Value \\ \hline</span><br><span class="line"> name1  &amp;  1    \\ \hline</span><br><span class="line"> name2  &amp;  2    \\ \hline</span><br><span class="line">\end&#123;tabular&#125;</span><br><span class="line">\end&#123;center&#125;</span><br><span class="line">\end&#123;table&#125;</span><br></pre></td></tr></table></figure></p><p>效果图如下：<br><img src="table.PNG" alt=""></p><h3 id="伪代码"><a href="#伪代码" class="headerlink" title="伪代码"></a>伪代码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\begin&#123;algorithm&#125;[H]</span><br><span class="line">    \SetAlgoLined</span><br><span class="line">    \SetKwInOut&#123;Input&#125;&#123;input&#125;</span><br><span class="line">    \SetKwInOut&#123;Output&#125;&#123;output&#125;</span><br><span class="line">    \Input&#123;Set $V$&#125;</span><br><span class="line">    \Output&#123;Out set $V_t$&#125;</span><br><span class="line">    init code \;</span><br><span class="line">    \While&#123;XXX&#125;&#123;</span><br><span class="line">        % do something</span><br><span class="line">        \For&#123;XXX&#125;&#123;</span><br><span class="line">            \If &#123;XXX&#125; &#123;</span><br><span class="line">                % do something</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        % do something</span><br><span class="line">    &#125;</span><br><span class="line">    \Return $V_t$;</span><br><span class="line"> \caption&#123;random&#125;</span><br><span class="line"> \label&#123;alg:random&#125;</span><br><span class="line">\end&#123;algorithm&#125;</span><br></pre></td></tr></table></figure><p>效果图如下：<br><img src="algorithm.PNG" alt=""></p><h2 id="其他需求："><a href="#其他需求：" class="headerlink" title="其他需求："></a>其他需求：</h2><ul><li><p>pdf自动生成书签，引用超链接(鼠标点击引用，直接到达被引用处)：</p>  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\usepackage[colorlinks,linkcolor=black,anchorcolor=black,citecolor=black,bookmarksopen,bookmarksdepth=2]&#123;hyperref&#125;</span><br></pre></td></tr></table></figure><ul><li>color用于控制引用标号[1],[2]等的颜色，</li><li>bookmarksopen，自动生成书签，由于LNCS特殊格式，bookmarksdepth = 2(<a href="https://tex.stackexchange.com/questions/52387/pdf-bookmarks-for-sections-and-subsections-with-the-llncs-class" target="_blank" rel="noopener">原因</a>)，其他格式需要自行调整，有的默认即可。</li></ul></li><li><p><a href="https://tex.stackexchange.com/questions/29816/algorithm-over-2-pages" target="_blank" rel="noopener">代码跨页显示</a></p></li><li>缩减图表与正文间距，在图表前后追加<code>\vspace*{-\baselineskip}</code></li><li>LaTex输入点  <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">\cdot   % 单个点</span><br><span class="line">\cdots  % 横向多个点</span><br><span class="line">\vdots  % 竖向多个点</span><br><span class="line">\ddots  % 斜向多个点</span><br></pre></td></tr></table></figure></li></ul><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>&emsp;&emsp;LaTeX学习成本还是要比Word高的，这几天的使用过程中感觉，LaTeX排版确实省心挺多，根据需求选择吧，Word和LaTeX都很好用，关键是得会用。以后如果有机会再深入研究一下，上边提到的各种东西的原理（往往说以后有机会的潜台词就是，哈哈哈）。有问题，多Google，嗯。</p><h2 id="参考文献-1"><a href="#参考文献-1" class="headerlink" title="参考文献"></a>参考文献</h2><ul><li><a href="https://liam0205.me/2014/09/08/latex-introduction/" target="_blank" rel="noopener">一份其实很短的 LaTeX 入门文档</a></li><li><a href="http://blog.csdn.net/garfielder007/article/details/51656911" target="_blank" rel="noopener">Springer LaTeX投稿模板说明 LATEX: LLNCS v2.4</a></li><li><a href="https://cn.sharelatex.com/learn/algorithms#/Algorithm2e_package" target="_blank" rel="noopener">Algorithm2e package</a></li><li><a href="http://blog.csdn.net/lilianforever/article/details/53079169" target="_blank" rel="noopener">Latex引用bib文件步骤</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LaTeX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>在这阳光灿烂的日子里</title>
      <link href="/2017/06/03/yangguangcanlan/"/>
      <url>/2017/06/03/yangguangcanlan/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;今天晚上，写完小论文初稿，开心的不行，目前看来一切如常行进~</p><p>&emsp;&emsp;找实习、想工作、想城市、想未来，短短几个月的时间，似乎我的未来就在这期间被慢慢规划出来。曾经听老师讲过这样一段话（大意）：对于未来的工作，于我们大体有三类标签，想做的、能做的、擅长做的。大部分人选择的工作往往只能具备其中一个或两个标签，能够拥有三份标签的工作，只能用幸福来形容吧。做自己喜欢做的事情，并且也很擅长，同时又能获得相应的物质与精神收益，这或许是所有人都梦寐以求的事情。最近看了一部日剧《四重奏》（本人看的第一部日剧，朋友推荐，确实相当不错），四个志同道合的朋友，想通过四重奏实现自己的音乐梦想，然而现实又似乎不容许他们如此“骄纵”自己，做音乐的收入并不理想，这种偏离“正常”轨道的生活，既让人向往，又让人无奈。那什么才是“正常”呢，上学-工作-结婚-生子，在什么年纪做什么事，难道所有人都应该这样么，而且什么又是“应该”呢？特别喜欢剧中小雀常说的一句话：燥起来了~（她每次表演前都会很兴奋，说这句话），生活中如果能充满那些可以让我们“燥起来”的事情，想想就开心。<br>&emsp;&emsp;想清楚自己想要什么样的生活，对于我这个没想法的人真是一个大问题。常常看到别人问该怎么选择工作，去大城市还是小城市？为此我也曾问过好多前辈，最终有一点明确了下来，每个人都有着自己的预期，如果现实生活可以达到自己的期许，那自己就是幸福的。因此无所谓好与坏，生活更多的是于己。自身纵向的比较可以给予自己更多自信，让自己笑的多一些。而现实中的横向比较也同样是不可缺少的，因为这毕竟是一个人与人的世界，我们需要看看外边的世界是怎样，别人是怎么生活的。无所谓好坏，但很耐人寻味的一件事情就是：我不知道自己不知道。<br>&emsp;&emsp;前两天找老师聊实习选择的事情，有意思的是我的两个指导老师有着截然不同的观点。一个老师建议我，年轻人就应该放开一些，做自己想做的事，不要有什么包袱。另一个则更加现实一些，实习的选择无外乎就是尝试做最优选择，既然是选择，那可以为自己制定一些标准（城市、工作状态、发展前景、钱等），每种标准都有权重，那这样就简单了，加权求最大值嘛（真是受不了你们理工男了，动不动就来这种东西）。这两种观点无关对错，同样是每个人的生活态度而已。真是又折磨了我好久，最终，我还是没能让自己“放纵”一回，现实的权重于我（只至少是目前状态的我）还是太大。<br>&emsp;&emsp;讲点开心的事吧，年后几个月来，自己瘦了5、6斤，肚子小了好多，真是开心的不行；前两天去体检，发现长高了两厘米，开心了两个星期，结果一天晚上，舍友突然对我说，那个体检没有压头发（以前体检都是有标尺压头发的），顿时，心塞。。。窝在学校几个月后，端午和妹妹去什刹海溜了一圈，两个人扎到情侣堆里只觉得来这真是脑袋被驴踢了，突来的雨更是应景。不过喝了一直没喝过的酸奶，发现了以前未发现的什刹海的美也还是挺好的；下午看了《摔跤吧，爸爸》，阿米尔·汗，这才是男神，记得大一的时候看三傻看得泪奔（真泪奔），现在的我泪点高了许多，但同样感动的不行。计划下面继续再开发开发新剧，开心。<br>&emsp;&emsp;真是好久没写东西了，上次写还是在QQ空间，往事呀。。。感觉这篇写的真是随意，我开心就好，反正是我的博客，嗯。<br>&emsp;&emsp;哈哈，其实未来还是有无限可能，在这阳光灿烂的日子里，正值阳光灿烂的我们，怎么能就此被圈养起来呢，还是燥起来吧。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 阳光灿烂 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>读书笔记-《Java并发编程实战》</title>
      <link href="/2017/02/26/ReadingNotes-JavaConcurrencyInPractice/"/>
      <url>/2017/02/26/ReadingNotes-JavaConcurrencyInPractice/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;寒假在家认真阅读了<a href="https://www.amazon.cn/~/dp/B0077K9XHW/ref=sr_1_1?ie=UTF8&amp;qid=1488119648&amp;sr=8-1&amp;keywords=java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E5%AE%9E%E6%88%98" target="_blank" rel="noopener">《Java并发编程实战》（英文名：Java Concurrency in Practice) </a>一书，过程中碰到了许多问题和值得深究的内容。在实际编程实践的同时，随手将个人疑惑的知识点通过查询相关资料进行补充说明，整理到了GitHub上。</p><h2 id="笔记目录"><a href="#笔记目录" class="headerlink" title="笔记目录"></a>笔记目录</h2><ol><li><a href="https://github.com/ZongWenlong/JavaLab/tree/master/src/main/java/multithread/tools/" target="_blank" rel="noopener">Java Concurrent Tools Class 并发工具类+自定义同步工具（非阻塞算法等）</a></li><li><a href="https://github.com/ZongWenlong/JavaLab/tree/master/src/main/java/multithread/task/executor" target="_blank" rel="noopener">Java Task Execution 任务的执行</a></li><li><a href="https://github.com/ZongWenlong/JavaLab/tree/master/src/main/java/multithread/task/close" target="_blank" rel="noopener">Java Task Cancel and Close 任务的取消与关闭</a></li><li><a href="https://github.com/ZongWenlong/JavaLab/tree/master/src/main/java/multithread/lock" target="_blank" rel="noopener">Java Lock 锁</a></li><li><a href="https://github.com/ZongWenlong/JavaLab/tree/master/src/main/java/multithread/pool" target="_blank" rel="noopener">Java Pool 线程池</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java源码阅读-DualPivotQuicksort</title>
      <link href="/2017/01/06/Java-SourceCode-Sort/"/>
      <url>/2017/01/06/Java-SourceCode-Sort/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;之前一直对JDK的排序算法很好奇，抽了点时间看了下源码，收获良多。其核心思想在于，根据数据的不同特性，动态的采用不同的排序算法，充分利用各种排序算法的优势，以期达到更好的综合效果。这篇文章只是Sort相关的源码一部分内容，之后会继续深入探究其他部分的内容。</p><h1 id="基本流程："><a href="#基本流程：" class="headerlink" title="基本流程："></a>基本流程：</h1><ul><li><p>如果长度小于<code>QUICKSORT_THRESHOLD(286)</code>，则采用非归并排序</p><ul><li>如果长度小于<code>INSERTION_SORT_THRESHOLD(47)</code>，则采用插入排序<ul><li>最左区间（以初始left开始的区间） <code>leftmost</code>：普通插入排序</li><li>否则：<code>pair insertion sort</code></li></ul></li><li><p>否则，快速排序</p><ul><li>将数组划分为7段（大约），然后找出第2、3、4、5、6段的右端点对应的位置</li><li>对这5个位置上的数字进行插入排序，作为枢轴的候选</li><li><p>如果5个数都不相等</p><ul><li>选取排序后的2、4作为枢轴，进行双枢轴排序<code>Dual-Pivot Quicksort</code></li><li><p>效果：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left part         center part                  right part</span><br><span class="line">+----------------------------------------------------------+</span><br><span class="line">| == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">+----------------------------------------------------------+</span><br></pre></td></tr></table></figure></li><li><p>排序后如果，中间部分元素过多，可能原因是等于pivort1和等于pivort2的元素过多，则将其调整为：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">left part         center part                  right part</span><br><span class="line">+----------------------------------------------------------+</span><br><span class="line">| == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span><br><span class="line">+----------------------------------------------------------+</span><br></pre></td></tr></table></figure></li></ul></li><li><p>否则，进行普通快速排序，枢轴排序后为第3个元素</p></li></ul></li></ul></li><li>否则，考虑Timsort(归并排序的优化版本，对一会升序、一会降序的混合情况处理比较好)<ul><li>创建Timsort run数组，大小为<code>MAX_RUN_COUNT(67) + 1</code><ul><li>a[run[i]] ~ a[run[i + 1]]之间为升序数组</li><li>检查当前待排序数组是否适合使用Timsort,即run数组中升序数组个数，如果个数不小于<code>MAX_RUN_COUNT</code>则认为数组内元素排序比较混乱，适合非归并排序<ul><li>注：对于连续下降的元素会将其调整为连续上升</li></ul></li></ul></li><li>如果通过上述检测，则进行归并排序      </li></ul></li></ul><h1 id="代码详解："><a href="#代码详解：" class="headerlink" title="代码详解："></a>代码详解：</h1><ul><li><p>普通的插入排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = left, j = i; i &lt; right; j = ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> ai = a[i + <span class="number">1</span>];      <span class="comment">// 带插入元素</span></span><br><span class="line">    <span class="keyword">while</span> (ai &lt; a[j]) &#123;     <span class="comment">// 寻找插入位置</span></span><br><span class="line">        a[j + <span class="number">1</span>] = a[j];</span><br><span class="line">        <span class="keyword">if</span> (j-- == left) &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    a[j + <span class="number">1</span>] = ai;          <span class="comment">// 插入新元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>改进的插入排序：pair insertion sort,每次插入两个元素</p><ul><li>pair insertion之所以不使用在做区间的原因，如果将其应用在左区间，需要增加额外的边界控制。但为什么没有左边界没有使用这种改良的插入排序呢？这一点还需要探究<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 注：left左侧的内容均已排好序，默认的前提条件</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Skip the longest ascending sequence.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (left &gt;= right) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> (a[++left] &gt;= a[left - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Every element from adjoining part plays the role</span></span><br><span class="line"><span class="comment"> * of sentinel, therefore this allows us to avoid the</span></span><br><span class="line"><span class="comment"> * left range check on each iteration. Moreover, we use</span></span><br><span class="line"><span class="comment"> * the more optimized algorithm, so called pair insertion</span></span><br><span class="line"><span class="comment"> * sort, which is faster (in the context of Quicksort)</span></span><br><span class="line"><span class="comment"> * than traditional implementation of insertion sort.</span></span><br><span class="line"><span class="comment"> * 一次遍历插入两个元素</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = left; ++left &lt;= right; k = ++left) &#123;</span><br><span class="line">    <span class="keyword">int</span> a1 = a[k], a2 = a[left];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 使得 a1 &gt;= a2</span></span><br><span class="line">    <span class="keyword">if</span> (a1 &lt; a2) &#123;</span><br><span class="line">        a2 = a1; a1 = a[left];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找a1的插入位置，相隔距离为2</span></span><br><span class="line">    <span class="keyword">while</span> (a1 &lt; a[--k]) &#123;</span><br><span class="line">        a[k + <span class="number">2</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[++k + <span class="number">1</span>] = a1;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 寻找a2的插入位置，相隔距离为1</span></span><br><span class="line">    <span class="keyword">while</span> (a2 &lt; a[--k]) &#123;</span><br><span class="line">        a[k + <span class="number">1</span>] = a[k];</span><br><span class="line">    &#125;</span><br><span class="line">    a[k + <span class="number">1</span>] = a2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将最后一个位置插入到合适位置</span></span><br><span class="line"><span class="keyword">int</span> last = a[right];</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (last &lt; a[--right]) &#123;</span><br><span class="line">    a[right + <span class="number">1</span>] = a[right];</span><br><span class="line">&#125;</span><br><span class="line">a[right + <span class="number">1</span>] = last;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>双枢轴排序<code>Dual-Pivot Quicksort</code></p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Inexpensive approximation of length / 7</span></span><br><span class="line"><span class="keyword">int</span> seventh = (length &gt;&gt; <span class="number">3</span>) + (length &gt;&gt; <span class="number">6</span>) + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Sort five evenly spaced elements around (and including) the</span></span><br><span class="line"><span class="comment"> * center element in the range. These elements will be used for</span></span><br><span class="line"><span class="comment"> * pivot selection as described below. The choice for spacing</span></span><br><span class="line"><span class="comment"> * these elements was empirically determined to work well on</span></span><br><span class="line"><span class="comment"> * a wide variety of inputs.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span> e3 = (left + right) &gt;&gt;&gt; <span class="number">1</span>; <span class="comment">// The midpoint</span></span><br><span class="line"><span class="keyword">int</span> e2 = e3 - seventh;</span><br><span class="line"><span class="keyword">int</span> e1 = e2 - seventh;</span><br><span class="line"><span class="keyword">int</span> e4 = e3 + seventh;</span><br><span class="line"><span class="keyword">int</span> e5 = e4 + seventh;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Sort these elements using insertion sort</span></span><br><span class="line"><span class="keyword">if</span> (a[e2] &lt; a[e1]) &#123; <span class="keyword">long</span> t = a[e2]; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[e3] &lt; a[e2]) &#123; <span class="keyword">long</span> t = a[e3]; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e4] &lt; a[e3]) &#123; <span class="keyword">long</span> t = a[e4]; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (a[e5] &lt; a[e4]) &#123; <span class="keyword">long</span> t = a[e5]; a[e5] = a[e4]; a[e4] = t;</span><br><span class="line">    <span class="keyword">if</span> (t &lt; a[e3]) &#123; a[e4] = a[e3]; a[e3] = t;</span><br><span class="line">        <span class="keyword">if</span> (t &lt; a[e2]) &#123; a[e3] = a[e2]; a[e2] = t;</span><br><span class="line">            <span class="keyword">if</span> (t &lt; a[e1]) &#123; a[e2] = a[e1]; a[e1] = t; &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pointers</span></span><br><span class="line"><span class="keyword">int</span> less  = left;  <span class="comment">// The index of the first element of center part</span></span><br><span class="line"><span class="keyword">int</span> great = right; <span class="comment">// The index before the first element of right part</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (a[e1] != a[e2] &amp;&amp; a[e2] != a[e3] &amp;&amp; a[e3] != a[e4] &amp;&amp; a[e4] != a[e5]) &#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use the second and fourth of the five sorted elements as pivots.</span></span><br><span class="line"><span class="comment">     * These values are inexpensive approximations of the first and</span></span><br><span class="line"><span class="comment">     * second terciles of the array. Note that pivot1 &lt;= pivot2.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> pivot1 = a[e2];</span><br><span class="line">    <span class="keyword">long</span> pivot2 = a[e4];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The first and the last elements to be sorted are moved to the</span></span><br><span class="line"><span class="comment">     * locations formerly occupied by the pivots. When partitioning</span></span><br><span class="line"><span class="comment">     * is complete, the pivots are swapped back into their final</span></span><br><span class="line"><span class="comment">     * positions, and excluded from subsequent sorting.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    a[e2] = a[left];</span><br><span class="line">    a[e4] = a[right];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Skip elements, which are less or greater than pivot values.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">while</span> (a[++less] &lt; pivot1);</span><br><span class="line">    <span class="keyword">while</span> (a[--great] &gt; pivot2);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Partitioning:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   left part           center part                   right part</span></span><br><span class="line"><span class="comment">     * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">     * |  &lt; pivot1  |  pivot1 &lt;= &amp;&amp; &lt;= pivot2  |    ?    |  &gt; pivot2  |</span></span><br><span class="line"><span class="comment">     * +--------------------------------------------------------------+</span></span><br><span class="line"><span class="comment">     *               ^                          ^       ^</span></span><br><span class="line"><span class="comment">     *               |                          |       |</span></span><br><span class="line"><span class="comment">     *              less                        k     great</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *              all in (left, less)   &lt; pivot1</span></span><br><span class="line"><span class="comment">     *    pivot1 &lt;= all in [less, k)     &lt;= pivot2</span></span><br><span class="line"><span class="comment">     *              all in (great, right) &gt; pivot2</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    outer:</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">        <span class="keyword">long</span> ak = a[k];</span><br><span class="line">        <span class="keyword">if</span> (ak &lt; pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">            a[k] = a[less];</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             - Here and below we use "a[i] = b; i++;" instead</span></span><br><span class="line"><span class="comment">             - of "a[i++] = b;" due to performance issue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            a[less] = ak;</span><br><span class="line">            ++less;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak &gt; pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">            <span class="keyword">while</span> (a[great] &gt; pivot2) &#123;</span><br><span class="line">                <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                    <span class="keyword">break</span> outer;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[great] &lt; pivot1) &#123; <span class="comment">// a[great] &lt;= pivot2</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                a[less] = a[great];</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt;= a[great] &lt;= pivot2</span></span><br><span class="line">                a[k] = a[great];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             - Here and below we use "a[i] = b; i--;" instead</span></span><br><span class="line"><span class="comment">             - of "a[i--] = b;" due to performance issue.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            a[great] = ak;</span><br><span class="line">            --great;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Swap pivots into their final positions</span></span><br><span class="line">    a[left]  = a[less  - <span class="number">1</span>]; a[less  - <span class="number">1</span>] = pivot1;</span><br><span class="line">    a[right] = a[great + <span class="number">1</span>]; a[great + <span class="number">1</span>] = pivot2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort left and right parts recursively, excluding known pivots</span></span><br><span class="line">    sort(a, left, less - <span class="number">2</span>, leftmost);</span><br><span class="line">    sort(a, great + <span class="number">2</span>, right, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * If center part is too large (comprises &gt; 4/7 of the array),</span></span><br><span class="line"><span class="comment">     * swap internal pivot values to ends.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (less &lt; e1 &amp;&amp; e5 &lt; great) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Skip elements, which are equal to pivot values.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (a[less] == pivot1) &#123;</span><br><span class="line">            ++less;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (a[great] == pivot2) &#123;</span><br><span class="line">            --great;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Partitioning:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *   left part         center part                  right part</span></span><br><span class="line"><span class="comment">         * +----------------------------------------------------------+</span></span><br><span class="line"><span class="comment">         * | == pivot1 |  pivot1 &lt; &amp;&amp; &lt; pivot2  |    ?    | == pivot2 |</span></span><br><span class="line"><span class="comment">         * +----------------------------------------------------------+</span></span><br><span class="line"><span class="comment">         *              ^                        ^       ^</span></span><br><span class="line"><span class="comment">         *              |                        |       |</span></span><br><span class="line"><span class="comment">         *             less                      k     great</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Invariants:</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         *              all in (*,  less) == pivot1</span></span><br><span class="line"><span class="comment">         *     pivot1 &lt; all in [less,  k)  &lt; pivot2</span></span><br><span class="line"><span class="comment">         *              all in (great, *) == pivot2</span></span><br><span class="line"><span class="comment">         *</span></span><br><span class="line"><span class="comment">         * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        outer:</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> k = less - <span class="number">1</span>; ++k &lt;= great; ) &#123;</span><br><span class="line">            <span class="keyword">long</span> ak = a[k];</span><br><span class="line">            <span class="keyword">if</span> (ak == pivot1) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                a[less] = ak;</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (ak == pivot2) &#123; <span class="comment">// Move a[k] to right part</span></span><br><span class="line">                <span class="keyword">while</span> (a[great] == pivot2) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (great-- == k) &#123;</span><br><span class="line">                        <span class="keyword">break</span> outer;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (a[great] == pivot1) &#123; <span class="comment">// a[great] &lt; pivot2</span></span><br><span class="line">                    a[k] = a[less];</span><br><span class="line">                    <span class="comment">/*</span></span><br><span class="line"><span class="comment">                     * Even though a[great] equals to pivot1, the</span></span><br><span class="line"><span class="comment">                     * assignment a[less] = pivot1 may be incorrect,</span></span><br><span class="line"><span class="comment">                     * if a[great] and pivot1 are floating-point zeros</span></span><br><span class="line"><span class="comment">                     * of different signs. Therefore in float and</span></span><br><span class="line"><span class="comment">                     * double sorting methods we have to use more</span></span><br><span class="line"><span class="comment">                     * accurate assignment a[less] = a[great].</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    a[less] = pivot1;</span><br><span class="line">                    ++less;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123; <span class="comment">// pivot1 &lt; a[great] &lt; pivot2</span></span><br><span class="line">                    a[k] = a[great];</span><br><span class="line">                &#125;</span><br><span class="line">                a[great] = ak;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Sort center part recursively</span></span><br><span class="line">    sort(a, less, great, <span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">else</span> &#123; <span class="comment">// Partitioning with one pivot</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Use the third of the five sorted elements as pivot.</span></span><br><span class="line"><span class="comment">     * This value is inexpensive approximation of the median.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">long</span> pivot = a[e3];</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Partitioning degenerates to the traditional 3-way</span></span><br><span class="line"><span class="comment">     * (or "Dutch National Flag") schema:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   left part    center part              right part</span></span><br><span class="line"><span class="comment">     * +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">     * |  &lt; pivot  |   == pivot   |     ?    |  &gt; pivot  |</span></span><br><span class="line"><span class="comment">     * +-------------------------------------------------+</span></span><br><span class="line"><span class="comment">     *              ^              ^        ^</span></span><br><span class="line"><span class="comment">     *              |              |        |</span></span><br><span class="line"><span class="comment">     *             less            k      great</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Invariants:</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     *   all in (left, less)   &lt; pivot</span></span><br><span class="line"><span class="comment">     *   all in [less, k)     == pivot</span></span><br><span class="line"><span class="comment">     *   all in (great, right) &gt; pivot</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * Pointer k is the first index of ?-part.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = less; k &lt;= great; ++k) &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[k] == pivot) &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">long</span> ak = a[k];</span><br><span class="line">        <span class="keyword">if</span> (ak &lt; pivot) &#123; <span class="comment">// Move a[k] to left part</span></span><br><span class="line">            a[k] = a[less];</span><br><span class="line">            a[less] = ak;</span><br><span class="line">            ++less;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[k] &gt; pivot - Move a[k] to right part</span></span><br><span class="line">            <span class="keyword">while</span> (a[great] &gt; pivot) &#123;</span><br><span class="line">                --great;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (a[great] &lt; pivot) &#123; <span class="comment">// a[great] &lt;= pivot</span></span><br><span class="line">                a[k] = a[less];</span><br><span class="line">                a[less] = a[great];</span><br><span class="line">                ++less;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123; <span class="comment">// a[great] == pivot</span></span><br><span class="line">                <span class="comment">/*</span></span><br><span class="line"><span class="comment">                 * Even though a[great] equals to pivot, the</span></span><br><span class="line"><span class="comment">                 * assignment a[k] = pivot may be incorrect,</span></span><br><span class="line"><span class="comment">                 * if a[great] and pivot are floating-point</span></span><br><span class="line"><span class="comment">                 * zeros of different signs. Therefore in float</span></span><br><span class="line"><span class="comment">                 * and double sorting methods we have to use</span></span><br><span class="line"><span class="comment">                 * more accurate assignment a[k] = a[great].</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                a[k] = pivot;</span><br><span class="line">            &#125;</span><br><span class="line">            a[great] = ak;</span><br><span class="line">            --great;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * Sort left and right parts recursively.</span></span><br><span class="line"><span class="comment">     * All elements from center part are equal</span></span><br><span class="line"><span class="comment">     * and, therefore, already sorted.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    sort(a, left, less - <span class="number">1</span>, leftmost);</span><br><span class="line">    sort(a, great + <span class="number">1</span>, right, <span class="keyword">false</span>);</span><br></pre></td></tr></table></figure></li><li><p>Timsort归并排序</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Index run[i] is the start of i-th run</span></span><br><span class="line"><span class="comment"> * (ascending or descending sequence).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">int</span>[] run = <span class="keyword">new</span> <span class="keyword">int</span>[MAX_RUN_COUNT + <span class="number">1</span>];</span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>; run[<span class="number">0</span>] = left;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check if the array is nearly sorted</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = left; k &lt; right; run[count] = k) &#123;</span><br><span class="line">    <span class="keyword">if</span> (a[k] &lt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// ascending</span></span><br><span class="line">        <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &lt;= a[k]);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (a[k] &gt; a[k + <span class="number">1</span>]) &#123; <span class="comment">// descending</span></span><br><span class="line">        <span class="comment">// 将降序数组变为升序</span></span><br><span class="line">        <span class="keyword">while</span> (++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] &gt;= a[k]);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> lo = run[count] - <span class="number">1</span>, hi = k; ++lo &lt; --hi; ) &#123;</span><br><span class="line">            <span class="keyword">int</span> t = a[lo]; a[lo] = a[hi]; a[hi] = t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// equal</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> m = MAX_RUN_LENGTH; ++k &lt;= right &amp;&amp; a[k - <span class="number">1</span>] == a[k]; ) &#123;</span><br><span class="line">            <span class="keyword">if</span> (--m == <span class="number">0</span>) &#123;</span><br><span class="line">                sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * The array is not highly structured,</span></span><br><span class="line"><span class="comment">     * use Quicksort instead of merge sort.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (++count == MAX_RUN_COUNT) &#123;</span><br><span class="line">        sort(a, left, right, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Check special cases</span></span><br><span class="line"><span class="comment">// Implementation note: variable "right" is increased by 1.</span></span><br><span class="line"><span class="keyword">if</span> (run[count] == right++) &#123; <span class="comment">// The last run contains one element</span></span><br><span class="line">    run[++count] = right;</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (count == <span class="number">1</span>) &#123; <span class="comment">// The array is already sorted</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Determine alternation base for merge</span></span><br><span class="line"><span class="comment">// 确定归并排序的迭代次数（每迭代一次，将相邻升序子序列合并，即run内元素数目减半）</span></span><br><span class="line"><span class="comment">// 简单示例：a[1, 5, 2, 6, 3, 7, 4, 8] ==&gt; a[1, 2, 5, 6, 3, 4, 7, 8]</span></span><br><span class="line"><span class="keyword">byte</span> odd = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; (n &lt;&lt;= <span class="number">1</span>) &lt; count; odd ^= <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use or create temporary array b for merging</span></span><br><span class="line"><span class="keyword">int</span>[] b;                 <span class="comment">// temp array; alternates with a</span></span><br><span class="line"><span class="keyword">int</span> ao, bo;              <span class="comment">// array offsets from 'left'</span></span><br><span class="line"><span class="keyword">int</span> blen = right - left; <span class="comment">// space needed for b</span></span><br><span class="line"><span class="keyword">if</span> (work == <span class="keyword">null</span> || workLen &lt; blen || workBase + blen &gt; work.length) &#123;</span><br><span class="line">    work = <span class="keyword">new</span> <span class="keyword">int</span>[blen];</span><br><span class="line">    workBase = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 根据归并的迭代次数，更改a,b</span></span><br><span class="line"><span class="comment">// a,b中必有一个数组为原始数组，另一个为临时数组</span></span><br><span class="line"><span class="comment">// 在归并的过程中，每迭代一次，run内元素数目减半，同时a,b会交换一次</span></span><br><span class="line"><span class="comment">// 为了保证最后一次迭代后，原始数组内存有归并好的数据，需要进行如下考虑</span></span><br><span class="line"><span class="keyword">if</span> (odd == <span class="number">0</span>) &#123;</span><br><span class="line">    System.arraycopy(a, left, work, workBase, blen);</span><br><span class="line">    b = a;</span><br><span class="line">    bo = <span class="number">0</span>;</span><br><span class="line">    a = work;</span><br><span class="line">    ao = workBase - left;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    b = work;</span><br><span class="line">    ao = <span class="number">0</span>;</span><br><span class="line">    bo = workBase - left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Merging</span></span><br><span class="line"><span class="comment">// a是原始数组，b是目标数组</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> last; count &gt; <span class="number">1</span>; count = last) &#123;</span><br><span class="line">    <span class="comment">// 合并两个相邻升序序列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> k = (last = <span class="number">0</span>) + <span class="number">2</span>; k &lt;= count; k += <span class="number">2</span>) &#123;</span><br><span class="line">        <span class="comment">// 确定边界</span></span><br><span class="line">        <span class="keyword">int</span> hi = run[k], mi = run[k - <span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = run[k - <span class="number">2</span>], p = i, q = mi; i &lt; hi; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (q &gt;= hi || p &lt; mi &amp;&amp; a[p + ao] &lt;= a[q + ao]) &#123;</span><br><span class="line">                b[i + bo] = a[p++ + ao];</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                b[i + bo] = a[q++ + ao];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 更新子序列标示</span></span><br><span class="line">        run[++last] = hi;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果升序子序列个数为奇数，之前两两合并时，最后会剩余一个，将剩余的直接拷贝到b, 等待下一次合并</span></span><br><span class="line">    <span class="keyword">if</span> ((count &amp; <span class="number">1</span>) != <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = right, lo = run[count - <span class="number">1</span>]; --i &gt;= lo;</span><br><span class="line">            b[i + bo] = a[i + ao]</span><br><span class="line">        );</span><br><span class="line">        run[++last] = right;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 交换a b</span></span><br><span class="line">    <span class="keyword">int</span>[] t = a; a = b; b = t;</span><br><span class="line">    <span class="keyword">int</span> o = ao; ao = bo; bo = o;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>Reference:</p><ul><li><a href="http://bindog.github.io/blog/2015/03/30/use-formal-method-to-find-the-bug-in-timsort-and-lunar-rover" target="_blank" rel="noopener">形式化方法的逆袭——如何找出Timsort算法和玉兔月球车中的Bug？</a></li><li><a href="http://lib.csdn.net/article/datastructure/9282" target="_blank" rel="noopener">排序算法—快速排序（JDK1.7 DualPivotQuicksort 源码解析）</a></li><li><a href="http://www.voidcn.com/blog/octopusflying/article/p-6181740.html" target="_blank" rel="noopener">JDK源码解析(1)——数据数组排序：Arrays.sort()</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 源码阅读 </tag>
            
            <tag> Sort </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Docker 常用命令</title>
      <link href="/2016/10/23/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2016/10/23/Docker-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;初学Docker，记录一些常用命令与配置方法。</p><h2 id="信息查看"><a href="#信息查看" class="headerlink" title="信息查看"></a>信息查看</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker info                  <span class="comment"># 查看docker基本信息</span></span><br><span class="line">docker images                <span class="comment"># 查看镜像列表</span></span><br><span class="line">docker ps                    <span class="comment"># 查看运行中的容器列表</span></span><br><span class="line">docker logs 819f822966a6     <span class="comment"># 查看容器运行log</span></span><br><span class="line">docker search (image-name)   <span class="comment"># 仓库中镜像查找</span></span><br><span class="line">docker stats                 <span class="comment"># 查看docker使用cpu、内存、网络、io情况</span></span><br></pre></td></tr></table></figure><h2 id="启动和终止容器"><a href="#启动和终止容器" class="headerlink" title="启动和终止容器"></a>启动和终止容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run busybox /bin/<span class="built_in">echo</span> Hello Docker          <span class="comment"># 容器名称“Helo Docker”</span></span><br><span class="line">docker start 819f822966a6                          <span class="comment"># 运行</span></span><br><span class="line">docker stop 819f822966a6                           <span class="comment"># 停止</span></span><br><span class="line">docker restart 819f822966a6                        <span class="comment"># 重启</span></span><br><span class="line">docker rm 819f822966a6                             <span class="comment"># 删除</span></span><br><span class="line">docker commit 819f822966a6 job1                    <span class="comment"># 将容器保存为镜像</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 进入容器内部</span></span><br><span class="line">docker <span class="built_in">exec</span> -it 775c7c9ee1e1 /bin/bash</span><br></pre></td></tr></table></figure><h2 id="导入和导出容器"><a href="#导入和导出容器" class="headerlink" title="导入和导出容器"></a>导入和导出容器</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">export</span> 7691a814370e &gt; ubuntu.tar   <span class="comment"># export</span></span><br></pre></td></tr></table></figure><h2 id="CentOS-7-迁移Docker目录"><a href="#CentOS-7-迁移Docker目录" class="headerlink" title="CentOS 7 迁移Docker目录"></a>CentOS 7 迁移Docker目录</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cp -r /var/lib/docker/ /data/docker  </span><br><span class="line">vim /lib/systemd/system/docker.service</span><br><span class="line">   ExecStart=/usr/bin/dockerd --graph=<span class="string">"/data/docker"</span></span><br><span class="line">systemctl daemon-reload   <span class="comment">#重新加载配置</span></span><br><span class="line">service docker restart    <span class="comment">#重启服务</span></span><br></pre></td></tr></table></figure><p><a href="https://docs.docker.com/engine/admin/systemd/" target="_blank" rel="noopener">参考</a></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>利用Docker快速搭建WordPress博客</title>
      <link href="/2016/10/07/%E5%88%A9%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWordPress%E5%8D%9A%E5%AE%A2/"/>
      <url>/2016/10/07/%E5%88%A9%E7%94%A8Docker%E5%BF%AB%E9%80%9F%E6%90%AD%E5%BB%BAWordPress%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;读研一年多了，一直想着给课题组里搭建一个博客网站，方便小伙伴们分享各种技术、产品经验，同时团队也能沉淀下一些东西。十一刚好没有什么事情，就查了查资料，用Docker和WordPress搭建了一个博客网站。下面记录一下一些搭建过程。</p><h2 id="选择"><a href="#选择" class="headerlink" title="选择"></a>选择</h2><ul><li>WordPress: 世界上应用最广泛的开源博客程序，基于PHP和MySQL数据库，特点是：安装简便，出了名的5分钟安装，并且功能强大。只是使用的话，无需后期编程，鼠标点点、键盘敲敲即可满足需求。</li><li>Docker：方便WordPress环境搭建以及后期备份，迁移。</li></ul><h2 id="Version-1-不推荐"><a href="#Version-1-不推荐" class="headerlink" title="Version 1 (不推荐)"></a>Version 1 (不推荐)</h2><ol><li><p>安装Docker （CentOS 7 为例）</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line"></span><br><span class="line">sudo tee /etc/yum.repos.d/docker.repo &lt;&lt;-<span class="string">'EOF'</span></span><br><span class="line">[dockerrepo]</span><br><span class="line">name=Docker Repository</span><br><span class="line">baseurl=https://yum.dockerproject.org/repo/main/centos/7/</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=1</span><br><span class="line">gpgkey=https://yum.dockerproject.org/gpg</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sudo yum install docker-engine       <span class="comment"># Install the Docker package</span></span><br><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service <span class="comment"># Enable the service</span></span><br><span class="line">sudo systemctl start docker          <span class="comment"># Start the Docker daemon.</span></span><br></pre></td></tr></table></figure></li><li><p>安装WordPress<br>&emsp;&emsp;使用WrodPress所需的基本环境：Apache + PHP + MySQL。本来想用Docker的lamp镜像，搜索了一下，发现WordPress就有镜像。但官方的WordPress镜像仍需要单独的MySQL数据库，后来搜索到了另外一个不错的镜像<a href="https://hub.docker.com/r/tutum/wordpress/" target="_blank" rel="noopener">tutum/wordpress</a>包含了WordPress运行所需的所有环境，所以直接拉取镜像、运行容器就好了。</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo docker pull tutum/wordpress                    <span class="comment"># 拉取镜像</span></span><br><span class="line">sudo docker run -d -p 80:80 tutum/wordpress  <span class="string">"blog"</span> <span class="comment"># 运行容器</span></span><br><span class="line">sudo curl http://localhost/                         <span class="comment"># 测试安装</span></span><br></pre></td></tr></table></figure></li><li><p>WordPress 自主配置(比较简单，细节不再累述)</p><ul><li>设置账号基本信息，进入控制台</li><li>选择主题</li><li>按个人需求，安装插件(JP Markdown等)</li><li>配置页面布局</li></ul></li><li><p>常用Docker命令</p><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="built_in">enable</span> docker.service <span class="comment"># Enable the service</span></span><br><span class="line">sudo systemctl start docker          <span class="comment"># Start the Docker daemon.</span></span><br><span class="line">sudo docker images                   <span class="comment"># Show local images</span></span><br><span class="line">sudo docker run -d -p 80:80 tutum/wordpress  <span class="string">"blog"</span>  <span class="comment"># Run container</span></span><br><span class="line">sudo docker stop <span class="string">"blog"</span>              <span class="comment"># Stop container</span></span><br><span class="line">sudo docker ps -a                    <span class="comment"># Show container list</span></span><br><span class="line">sudo docker <span class="built_in">export</span> 7691a814370e &gt; blog.tar                          <span class="comment"># Export container</span></span><br><span class="line">cat blog.tar | sudo docker import - tutum/wordpress blog.tar        <span class="comment"># Import container</span></span><br></pre></td></tr></table></figure></li></ol><h2 id="Version-2-推荐"><a href="#Version-2-推荐" class="headerlink" title="Version 2 (推荐)"></a>Version 2 (推荐)</h2><p>&emsp;&emsp;其实Docker官方有wordpress的安装实例文档，也可以实现一键安装，详情请见：<a href="https://docs.docker.com/compose/wordpress/" target="_blank" rel="noopener">Quickstart: Compose and WordPress</a></p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;&emsp;本文仅仅是对Docker的简单使用，Docker、OpenStack相关的云平台、容器技术以后会继续关注。最后放一张搭建完的博客图。<br><img src="blog.PNG" alt=""> </p><h2 id="主要参考"><a href="#主要参考" class="headerlink" title="主要参考"></a>主要参考</h2><blockquote><ol><li>详细Docker安装即使用步骤请看 <a href="https://docs.docker.com/engine/installation/linux/centos/" target="_blank" rel="noopener">Docker官方文档</a></li><li>Docker使用介绍 <a href="https://www.gitbook.com/book/yeasy/docker_practice/details" target="_blank" rel="noopener">Docker —— 从入门到实践</a></li><li><a href="https://hub.docker.com/r/tutum/wordpress/" target="_blank" rel="noopener">tutum/wordpress</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> WordPress </tag>
            
            <tag> 容器 </tag>
            
            <tag> 团队分享 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>RESTful SpringMVC Swagger Demo</title>
      <link href="/2016/09/18/RESTful-SpringMVC-Swagger-Demo/"/>
      <url>/2016/09/18/RESTful-SpringMVC-Swagger-Demo/</url>
      
        <content type="html"><![CDATA[<p>SpringMVC框架搭建 RESTful 风格后端服务器示例<br>源码：<a href="https://github.com/ZongWenlong/RESTful-SpringMVC-Swagger-Demo" target="_blank" rel="noopener">RESTful-SpringMVC-Swagger-Demo</a></p><h1 id="简介："><a href="#简介：" class="headerlink" title="简介："></a>简介：</h1><h2 id="涉及框架或数据库"><a href="#涉及框架或数据库" class="headerlink" title="涉及框架或数据库"></a>涉及框架或数据库</h2><ul><li>SpringMVC 框架</li><li>Spring 框架</li><li>MyBatis 框架</li><li>Log4j 日志框架</li><li>MySQL 数据库</li><li>Redis 数据库</li><li>Swagger-UI API接口管理工具</li></ul><h2 id="Try-it"><a href="#Try-it" class="headerlink" title="Try it"></a>Try it</h2><ol><li>导入项目到<code>IDEA/Eclipse</code>中</li><li>初始化数据库，导入<code>tools/mysql-init.sql</code>到MySQL数据库（本示例仅包含一张表，一条记录）</li><li>配置MySQL和Redis，修改<code>src//main/resource/database.properties</code><ul><li>mysql.url</li><li>mysql.username</li><li>mysql.password</li><li>redis.host</li></ul></li><li><p>修改<code>src/main/webapp/WEB-INF/swagger-ui/index.html</code></p> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">url = &quot;http://localhost:8888/api-docs&quot;;</span><br><span class="line">修改为：</span><br><span class="line">url = &quot;http://ip:port/&#123;项目名&#125;/api-docs</span><br></pre></td></tr></table></figure></li><li><p>启动</p></li><li>浏览器中查看<code>http://ip:port/{项目名}/swagger/index.html</code>页面显示如下： <img src="https://github.com/ZongWenlong/Demos/blob/master/images/swagger/api-examples.PNG" alt="image"></li></ol><h1 id="具体说明："><a href="#具体说明：" class="headerlink" title="具体说明："></a>具体说明：</h1><h2 id="请求响应过程"><a href="#请求响应过程" class="headerlink" title="请求响应过程"></a>请求响应过程</h2><ul><li>登录：请求中携带用户名密码，获取Token, 为简单起见本示例只要用户名和密码相同则验证通过<ul><li>Token<ul><li>凭证信息，用户在之后的请求中用Token中的字符串代替密码供鉴权使用，并有一定的使用期限</li><li>为加速查询，Token字符串存储在Redis中，存储格式为Key-Value（name-tokenStr）</li></ul></li></ul></li><li>鉴权：除登录外的其他操作原则上均需要经过鉴权才能使用系统的API<ul><li>本示例中利用拦截器<code>src/java/pers/well/interceptor/AuthorizationInterceptor</code>拦截请求，进行Token正确性验证</li><li><code>AuthorizationInterceptor</code> 在<code>src/main/resource/spring-mvc.xml</code>中配置</li></ul></li></ul><h2 id="接口说明"><a href="#接口说明" class="headerlink" title="接口说明"></a>接口说明</h2><ul><li>示例中有三个接口：/login, /student, token/student</li><li>/login<ul><li>请求中携带用户名密码，获取Token</li></ul></li><li>/student<ul><li>无token示例，提供简单的id参数即可进行查询</li></ul></li><li>/token/student<ul><li>需要鉴权的接口示例，必须携带正确的token和username，否则鉴权失败</li></ul></li></ul><h2 id="部分配置项说明"><a href="#部分配置项说明" class="headerlink" title="部分配置项说明"></a>部分配置项说明</h2><ul><li><p><code>src/main/resource/</code>目录：</p><ul><li>database.properties: 数据库相关配置</li><li>log4j.properties: log4j日志配置</li><li>mybatis-config.xml: mybatis分页插件等相关配置</li><li>spring.xml: redis等配置</li><li>spring-mvc.xml： springmvc配置</li><li>spring-mybatis.xml: spring,mybatis整合配置</li></ul></li></ul><h2 id="Swagger-UI说明"><a href="#Swagger-UI说明" class="headerlink" title="Swagger-UI说明"></a>Swagger-UI说明</h2><ul><li><p>SpringMVC项目中引入Swagger的主要步骤：</p><ul><li>添加个性化配置：<code>src/java/pers/well/config/SwaggerConfig.java</code></li><li>Copy Swagger-UI界面部分<a href="https://github.com/swagger-api/swagger-ui/tree/master/dist" target="_blank" rel="noopener">SWagger-UI</a> 到<code>webapp/WEB-INF/swagger-ui</code></li><li><p>Spring配置</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;bean class=&quot;pers.well.config.SwaggerConfig&quot; /&gt;</span><br><span class="line">&lt;mvc:resources mapping=&quot;/swagger/**&quot; location=&quot;/WEB-INF/swagger-ui/&quot;/&gt;</span><br></pre></td></tr></table></figure></li><li><p>Controller中可以自主添加配置，更好的显示API：</p><ul><li>@API</li><li>@ApiOperation</li><li>@ApiModel</li><li>@ApiModelProperty</li></ul></li></ul></li></ul><p>主要参考：</p><blockquote><ol><li><a href="https://github.com/albertchendao/demos/tree/master/java/spring/HelloWorld-MVC-Swagger" target="_blank" rel="noopener">HelloWorld-MVC-Swagger</a></li><li><a href="https://www.javacodegeeks.com/2013/10/swagger-make-developers-love-working-with-your-rest-api.html" target="_blank" rel="noopener">Swagger: make developers love working with your REST API</a></li></ol></blockquote><h2 id="其他说明："><a href="#其他说明：" class="headerlink" title="其他说明："></a>其他说明：</h2><ul><li>MyBatisGeneratorConfig.xml MyBatis代码自动生成器配置，可以根据数据库表信息自动反向生成MyBatis Mapper等文件，详细说明见 <a href="http://generator.sturgeon.mopaas.com/index.html" target="_blank" rel="noopener">MyBatis Generator</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> RESTful </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>西藏游记（六人七天）</title>
      <link href="/2016/09/03/%E8%A5%BF%E8%97%8F%E6%B8%B8%E8%AE%B0%EF%BC%88%E5%85%AD%E4%BA%BA%E4%B8%83%E5%A4%A9%EF%BC%89/"/>
      <url>/2016/09/03/%E8%A5%BF%E8%97%8F%E6%B8%B8%E8%AE%B0%EF%BC%88%E5%85%AD%E4%BA%BA%E4%B8%83%E5%A4%A9%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;西藏，一个神秘而遥远的地方。一直以来，我就想去这个离太阳最近的地方看看。这个暑假，在小伙伴的相互“逼迫”下，我们终于来到了这个让人痴醉的地方。<br>&emsp;&emsp;在西藏，我们一共呆了7天。7天里，我第一次经历长时间的“汽车旅行”，第一次看到如此湛蓝的天空、湖水，第一次尝试手脚并用攀爬小山——只为离那冰川更近一点，第一次觉得世界上竟然能有这样一个地方如此让人难以忘怀，期待着与她的再次相遇。 </p><h1 id="美图优先"><a href="#美图优先" class="headerlink" title="美图优先"></a>美图优先</h1><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">先放一波大图，后边是详细旅行攻略</span><br></pre></td></tr></table></figure><p><em>注：以下图片大部分来源于同行小伙伴 <a href="http://weibo.com/u/2175302752?refer_flag=1001030201_&amp;is_hot=1&amp;noscale_head=1#_0" target="_blank" rel="noopener">襄阳少陵</a> 转载请说明</em></p><h2 id="Day-0"><a href="#Day-0" class="headerlink" title="Day 0"></a>Day 0</h2><p>&emsp;&emsp;北京出发，西宁转站，终点拉萨。火车上，一觉醒来，四周都是旷野，远离了城市，没有了喧嚣，有的只是那偶尔出没的藏羚羊、藏野驴，遍地的牦牛，远方的雪山以及山下的小村庄，。<br><img src="0-bridge.JPG" alt=""><br><img src="0-train.JPG" alt=""><br><img src="0-jokul.JPG" alt=""></p><h2 id="Day-1"><a href="#Day-1" class="headerlink" title="Day 1"></a>Day 1</h2><p>&emsp;&emsp;拉萨休整一晚后，我们现在市区逛了一天：布达拉宫-大昭寺-八廓街。<br><img src="1-potala.JPG" alt=""><br><img src="1-temple.JPG" alt=""><br><img src="1-pilgrim.JPG" alt=""></p><h2 id="Day-2-4"><a href="#Day-2-4" class="headerlink" title="Day 2 - 4"></a>Day 2 - 4</h2><p>&emsp;&emsp;接下来是三天的林芝“征程”，称之为征程，并不为过——途中正在修路，所以，我们9点离开拉萨，晚上10点多才到达住宿的地方，返程稍好一点；加之运气不好，在雅鲁藏布江大峡谷也没看到南迦巴瓦峰，只看到厚厚的云层和突来的大雨。当然，这段旅程总归还是有惊喜的——扎西岗村。当晚我们就住在了这个小村子（入藏后睡得最好的一天），第二天醒来，听到窗外淅淅沥沥下起了小雨，不禁担心起了即将开始的行程。好在起床后雨就停了，然后出门在村周围逛了逛，没看到传说中的花海（已经谢了），但代之以别样的美丽。<br><img src="2-car.JPG" alt=""><br><em>米拉山口</em><br><img src="2-col.JPG" alt=""><br><em>鲁朗，晚上大家吃了一顿石锅鸡，顿时能量回复</em><br><img src="2-lulang.jpg" alt=""><br><em>扎西岗村</em><br><img src="2-zha-1.JPG" alt=""><br><img src="2-zha-2.JPG" alt=""><br><img src="2-zha-3.jpg" alt=""><br><img src="2-cow.JPG" alt=""><br><em>这只有意思的小牛，摄影师在哪，它就会转向哪里，拍照时，感觉就和假的一样，一动也不动。小插曲：穿了红色外套的我差点被顶到，哈哈！</em><br><em>大峡谷-雅鲁藏布江</em><br><img src="2-gu.JPG" alt=""><br><img src="2-jiang.JPG" alt=""><br><em>期待中的南迦巴瓦峰——中国最美山峰—（<a href="http://www.360doc.com/content/11/0418/18/6017453_110573678.shtml" target="_blank" rel="noopener">来源网络图片</a>）</em><br><img src="2-nanjia-1.jpg" alt=""><br><em>实际看到的南迦巴瓦峰，无奈天公不作美</em><br><img src="2-nanjia-2.jpg" alt=""></p><h2 id="Day-5"><a href="#Day-5" class="headerlink" title="Day 5"></a>Day 5</h2><p>&emsp;&emsp;结束“辛苦”的三天林芝之行，下一站：羊湖-卡若拉冰川。美丽的羊湖，美到无意附加！<br><em>如梦如幻</em><br><img src="5-mei.JPG" alt=""><br><img src="5-jin.JPG" alt=""><br><img src="5-qi.jpg" alt=""><br><em>卡若拉冰川，手脚并用爬到了离它最近的地方</em><br><img src="5-glacier.jpg" alt=""></p><h2 id="Day-6-7"><a href="#Day-6-7" class="headerlink" title="Day 6 - 7"></a>Day 6 - 7</h2><p>&emsp;&emsp;西藏之行，最后一站——纳木错，美不美，有图为证<br><img src="6-0.jpg" alt=""><br><img src="6-1.jpg" alt=""><br><img src="6-2.jpg" alt=""><br><em>小伙伴拍的银河，远离城市，重新看到小时候看到过的星空。（还看到好几颗流星，默默许下愿望，哈哈！）</em><br><img src="6-galaxy.JPG" alt=""><br><em>据说到了纳木错，一定要看日出日落，日落的确很美，但日出很普通，可能是前几日审美疲劳了吧</em><br><img src="6-sunset.JPG" alt=""><br><em>去纳木错，捎带一个姐姐一起去的，姐姐平摊的车费被我们拿来在最后一天吃了顿自助火锅餐，算是缓解了下吃了7天川菜的怨念。</em></p><h1 id="攻略总结"><a href="#攻略总结" class="headerlink" title="攻略总结"></a>攻略总结</h1><p>&emsp;&emsp;西藏的旅行以拉萨为中心，7/8月份为旺季。我们首先确定的是在入藏和离藏时间。由于火车车票不好购买等原因，最终确定总时长11天，往返路上4天，在西藏游玩7天。接下来开始制定具体的行程。</p><h2 id="最初设想"><a href="#最初设想" class="headerlink" title="最初设想"></a>最初设想</h2><p><img src="final-old.png" alt=""><br>主要参看<a href="http://www.mafegwo.cn/localdeals/mdd_topic_297/?cid=1010607" target="_blank" rel="noopener">小伙伴找到的攻略介绍</a><br>但由于后来包车，以及路况原因，行程进行了调整。</p><h2 id="实际方案"><a href="#实际方案" class="headerlink" title="实际方案"></a>实际方案</h2><p><img src="final-new.jpg" alt=""><br><strong>具体安排如下：</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">D1: 拉萨一日游</span><br><span class="line">D2: 拉萨--米拉山口--尼洋河--鲁朗林海--扎西岗村（宿） </span><br><span class="line">D3: 扎西岗村--色季拉山口观南迦巴瓦峰--江河交汇处--雅鲁藏布江大峡谷--林芝（宿）</span><br><span class="line">D4: 林芝-卡定沟-拉萨（宿）</span><br><span class="line">D5: 拉萨-羊湖-拉萨（宿）</span><br><span class="line">D6: 拉萨-那根拉山口-纳木错日落（宿）</span><br><span class="line">D7: 纳木错-念青唐古拉山-羊八井-拉萨（宿）</span><br></pre></td></tr></table></figure></p><p>注：</p><ul><li>去林芝会一路沿着318国道（大部分挨着尼洋河）行进</li><li>江河交汇处——尼洋河和雅鲁藏布江交汇的地方，水一半绿（尼洋河）、一半黄（雅江）</li></ul><h3 id="行"><a href="#行" class="headerlink" title="行"></a>行</h3><p>&emsp;&emsp;去西藏旅行最大的问题就是交通。所以，先说一下交通问题。<br>&emsp;&emsp;拉萨市区交通便利，打车、公交均可。市区以外的地方，就需要考虑：自驾、包车、客运大巴、火车（拉萨到日喀则，其他地方基本没有）。我们一共六个人，所以包了一个7座车。在西藏见到较多的，除了像我们一样直接包车的同学，还有一些就是跟旅行团或驴友拼车。由于景点之间之间都比较远，而且很多“景点”都是像米拉山口、鲁朗林海这些都是路过看一看就走的地方，所以，入藏，先想好交通问题如何解决。<br>&emsp;&emsp;由于缺少包车信息，我们是在阿里旅行上找了中介，联系到的包车师傅（价格6天7000元）。由于车辆问题，我们中间更换了一个包车师傅，但两位藏族师傅人都很好，后边我会附上他们的联系方式。以后去西藏的朋友可以联系，价格肯定比我们这个便宜，毕竟少了中介嘛。<br>&emsp;&emsp;需要单独说一下的是，林拉公路（林芝到拉萨）估计还要修好长一段时间，所以想去林芝的朋友可以事先打听一下，公路维修状况。如果像我们一样单程需要十几个小时，我建议还是放弃林芝，去亚东（住宿地方的老板推荐）吧，那边风景也不错，何苦忍受两天颠簸呢。当然飞机出行的除外（林芝有机场）。</p><blockquote><p>包车师傅1：扎西（139 8998 8015），人好，车技好<br>包车师傅2：平措（180 0891 1060），开车相较前一个师傅较慢，但人很好，一路时不时唱一唱藏族歌曲</p></blockquote><h3 id="住"><a href="#住" class="headerlink" title="住"></a>住</h3><p>&emsp;&emsp;青旅为主，人均价位50-60/晚</p><ul><li>拉萨：我们在拉萨一共住了五天，一直都在“拉萨藏悦生活青年客栈”，老板微微姐人很好，客栈里还有一只“呆呆”狗，环境也还不错，附近有个大超市，比较方便。</li><li>林芝：住的“林芝县贰加贰花园主题客栈”，环境不错，老板人也不错。小伙伴最后都把人家房门钥匙带回来了，哈哈！</li><li>扎西岗村：扎西师傅找的地方，村里都是小客栈，小院非常好看，就是照片里萌牛那个地方。</li><li>纳木错：纳木错那边基本都是活动板房，所以我们也就无所谓了，扎西师傅找的地方，凑合了一宿。</li></ul><h3 id="食"><a href="#食" class="headerlink" title="食"></a>食</h3><ul><li>早餐：拉萨遍地都是甜茶馆，我们的早餐基本都在住宿附加的甜茶馆：酥油茶（不太习惯）、甜茶（喝了7天）、藏面（肉好吃）、肉饼、牛奶。</li><li>午餐：川菜，午餐一般都是在行车途中解决，在西藏，途中能吃饭的地方基本都是川菜馆。所以，我们也只能去了。米饭一般不熟，凑合吃（第一次怀念起了学校食堂的米饭），菜价基本看凉拌黄瓜就可以知道，不太一致（人均30-50）。</li><li>晚餐：面食为主，当然也可以川菜。</li></ul><h3 id="衣"><a href="#衣" class="headerlink" title="衣"></a>衣</h3><ul><li>纳木错以外的地方：一件带绒薄外套 + 短袖</li><li>纳木错：羽绒服，太阳下山后真的很冷</li></ul><h3 id="其他注意事项"><a href="#其他注意事项" class="headerlink" title="其他注意事项"></a>其他注意事项</h3><ul><li>高反：我们一行人，除了在火车经过那曲那边高海拔（4000-5000）地方时，有轻微的头痛、恶心外，在其他地方都没事，包括纳木错。刚到拉萨，可能上个楼梯都大喘，但休息一晚后面就好很多。我们没有吃药、吸氧，毕竟我们没有去珠峰之类的海拔较高的地方。火车上倒是有见吸氧的乘客，但很少。总之，放平心态最重要，多喝水，走路慢一点，不用太担心。</li><li>防晒保湿：重要，我们带了帽子、防晒霜（虽然是男生，但也用了）、墨镜、唇膏（有些干）。。。</li></ul><h2 id="结语"><a href="#结语" class="headerlink" title="结语"></a>结语</h2><p>&emsp;&emsp;总的来看，去西藏还是比较“麻烦”的，所以开始时我也萌生退意，但感谢同行小伙伴的“逼迫”，西藏很美，不虚此行，也算是圆了一个梦。以后有机会我还是想去西藏走一走，去看看珠峰、亚东、阿里，看看西藏的其他地方。正所谓“走走停停，放空自己，体味真正的纯净”。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 西藏 </tag>
            
            <tag> 旅游 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>并发编程(1)-单例模式和volatile</title>
      <link href="/2016/06/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)-%E4%BB%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7/"/>
      <url>/2016/06/01/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B(1)-%E4%BB%8E%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%E8%AF%B4%E8%B5%B7/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;之前在找实习的时候，被N次问过，你用过什么设计模式么，或者你知道有什么设计模式么？每次我都只会羞愧的说，单例模式，面试官就会说，那就写一下吧。然后我就把直接背诵过得模板的写了出来。当时羞愧的原因是我只会一种设计模——单例模式。关于设计模式这个坑会在之后进行填补，现在的我才意识到还有个地方更应该感到羞愧——唯一看过的单例模式还写的有问题。</p><h1 id="痛苦的回顾"><a href="#痛苦的回顾" class="headerlink" title="痛苦的回顾"></a>痛苦的回顾</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;这是我之前面试时写过的代码，记得当时还有面试官问过我这样写有什么问题么，甚至他还在提示我，多线程下会有什么问题么？我信誓旦旦的觉得反正加了synchronized了，就没有问题了。事实证明，我是too young, too simple！</p><h1 id="问题的解决"><a href="#问题的解决" class="headerlink" title="问题的解决"></a>问题的解决</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">            <span class="keyword">synchronized</span>(Singleton.class)&#123;</span><br><span class="line">                <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;上面的代码中，如果我们在为成员变量singleton添加volatile关键字进行修饰，原本的线程安全问题就会被解决，为什么呢？</p><h2 id="问题的由来"><a href="#问题的由来" class="headerlink" title="问题的由来"></a>问题的由来</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Singleton <span class="title">getInstance</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(instance == <span class="keyword">null</span>)&#123;           <span class="comment">//Point1: 线程A</span></span><br><span class="line">            instance = <span class="keyword">new</span> Singleton(); <span class="comment">//Point2: 线程B</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;&emsp;对于这段代码，大家很容易就能明白，多线程环境下，这个单例是存在问题的。比如：假设线程A执行到Point1，线程B执行到Point2，那么线程A可能看到还未被线程B初始化完毕的singleton。所以就会出现问题。<br>对于instance = new Singleton();这一条语句可以大致分解为三步:<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">memory = allocate();   <span class="comment">//1：分配对象的内存空间</span></span><br><span class="line">initObject(memory);    <span class="comment">//2：初始化对象</span></span><br><span class="line">instance = memory;     <span class="comment">//3：设置instance指向刚分配的内存地址</span></span><br></pre></td></tr></table></figure></p><p>&emsp;&emsp;线程B可能正在初始化instance，线程A就得到了空的对象，也开始了初始化，这当然是违背单例的思想的。那是不是像我在开始部分的代码中加入synchronized同步块就可以了呢，因为这样可以保证这段代码在同一时间只有一个线程访问。<br>&emsp;&emsp;其实，这三条语句的顺序，并不一定是1,2,3顺序执行，由于编译器的原因，顺序可能变为1,3,2。也就是所谓的指令重排。如果是这样的话，那问题就严重了。线程B还没有初始化instance，线程A就可以再不进入同步块的前提下得到了一个非空的对象，然后就去使用了，这显然是有问题的。</p><h2 id="Volatile"><a href="#Volatile" class="headerlink" title="Volatile"></a>Volatile</h2><p>为什么加上volatile后问题就不存在了呢？<br>volatile在Java中的保证如下：</p><ul><li>保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的。对volatile成员变量的读和写都是原子的。不会读到没有写入的值：只有读和写两个操作是原子的，像x++、x+=2这种表达式还是相当于先读，然后再写，两次进行，可以读到中间的值。即使是x=2这样的赋值操作，JVM并不能保证long,double这种64位数据类型（引用类型除外，它的读写始终都是原子的）读写的原子性，需要程序自己控制。另外过synchronized和Lock也能够保证可见性，synchronized和Lock能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。<blockquote><p>Some implementations may find it convenient to divide a single write action on a 64-bit long or double value into two write actions on adjacent 32 bit values. For efficiency’s sake, this behavior is implementation specific; Java virtual machines are free to perform writes to long and double values atomically or in two parts.<br>For the purposes of the Java programming language memory model, a single write to a non-volatile long or double value is treated as two separate writes: one to each 32-bit half. This can result in a situation where a thread sees the first 32 bits of a 64 bit value from one write, and the second 32 bits from another write. Writes and reads of volatile long and double values are always atomic. Writes to and reads of references are always atomic, regardless of whether they are implemented as 32 or 64 bit values.<br>VM implementers are encouraged to avoid splitting their 64-bit values where possible. Programmers are encouraged to declare shared 64-bit values as volatile or synchronize their programs correctly to avoid possible complications.<br>—— from JLS section 17.7: Non-atomic Treatment of double and long</p></blockquote></li></ul><ul><li>禁止指令重排序，对所有的volatile的变量的所有次读写操作，组成一个全局的全序关系。全序关系的意思是：任何两个操作之间都可以比较先后关系。这个全序关系叫“同步顺序”(synchronization order)。这个同步顺序和“程序顺序”(program order，也就是单个线程里各个操作的顺序)是一致的。根据这个顺序，每次读操作，看到的一定是它之前最后一次对同一个变量写的值，如果它之前没有对这个变量的写操作，就读到初始值（0、null、false）。这可以避免指令重排问题。</li></ul><p>总之，当我们加上volatile后，可以禁止语句2,3的重排序，也就可以避免多线程不安全问题。<br>既然谈到了volatile，它除了双重检查锁定外还有一些其他用途,如：状态标记量<br><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> flag = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(!flag)&#123;</span><br><span class="line">    doSomething();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setFlag</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    flag = <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>其他的应用可以阅读：<a href="http://www.ibm.com/developerworks/cn/java/j-jtp06197.html" target="_blank" rel="noopener">Java 理论与实践: 正确使用 Volatile 变量</a></p><h1 id="Other-Way"><a href="#Other-Way" class="headerlink" title="Other Way?"></a>Other Way?</h1><p>&emsp;&emsp;当修复了多线程安全问题后，是不是说上述方式就是单例模式的最佳实现呢？其实不是的，还有其他的单例模式的解决方案：<br>(PS: 前面提到的解决方案被成为Lazy initialization)</p><h2 id="Eager-initialization"><a href="#Eager-initialization" class="headerlink" title="Eager initialization"></a>Eager initialization</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在类进行初始化时，static变量也会被初始化，并且JVM可以保证线程安全，即static部分只会被初始化一次，并且只有被初始化后才能被本线程或其他线程使用。（final域的对象具备初始化安全性，初始化安全性可以防止对象的初始引用被重排序到给构造过程之前。并且保证所有线程都能看由构造函数为final域设置的正确值）</p><h2 id="Initialization-on-demand-holder-idiom"><a href="#Initialization-on-demand-holder-idiom" class="headerlink" title="Initialization-on-demand holder idiom"></a>Initialization-on-demand holder idiom</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="title">Singleton</span><span class="params">()</span> </span>&#123; &#125;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Initializes singleton.</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> SingletonHolder&#125; is loaded on the first execution of &#123;<span class="doctag">@link</span> Singleton#getInstance()&#125; or the first access to</span></span><br><span class="line"><span class="comment">     * &#123;<span class="doctag">@link</span> SingletonHolder#INSTANCE&#125;, not before.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">SingletonHolder</span> </span>&#123;</span><br><span class="line">            <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">final</span> Singleton INSTANCE = <span class="keyword">new</span> Singleton();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> SingletonHolder.INSTANCE;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于静态内部类SingletonHolder，并不会在Singleton初始化时就初始化，只有SingletonHolder被第一次使用时即getInstance()被调用时，INSTANCE才会被初始化。</p><h2 id="The-enum-way"><a href="#The-enum-way" class="headerlink" title="The enum way"></a>The enum way</h2><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> Singleton &#123;</span><br><span class="line">    INSTANCE;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span> <span class="params">(String arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// Perform operation here</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>《Effective Java》一书中建议的实现Singleton的最佳方法</p><h1 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a>参考文献</h1><blockquote><ol><li><a href="https://en.wikipedia.org/wiki/Singleton_pattern" target="_blank" rel="noopener">Singleton pattern</a></li><li><a href="http://ifeve.com/double-checked-locking-with-delay-initialization/" target="_blank" rel="noopener">双重检查锁定与延迟初始化</a></li><li><a href="https://bbs.byr.cn/#!article/Java/39220" target="_blank" rel="noopener">歪楼的volatile</a></li><li><a href="http://www.cnblogs.com/dolphin0520/p/3920373.html" target="_blank" rel="noopener">Java并发编程：volatile关键字解析</a></li></ol></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
            <tag> 并发 </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Little Tips（持续更新）</title>
      <link href="/2016/05/25/Little-Tips/"/>
      <url>/2016/05/25/Little-Tips/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;收录一些开发中的小技巧</p><h1 id="Code-Style"><a href="#Code-Style" class="headerlink" title="Code Style"></a>Code Style</h1><h2 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h2><ul><li>源文件<ul><li>编码：UTF-8</li><li>文件结构（各部分之间有且仅有一个空行）：<ul><li>License or copyright 信息</li><li>Package 声明</li><li>Import 声明：无通配符import</li><li>一个top-level类</li></ul></li></ul></li><li><p>大括号</p><ul><li><p>非空代码块</p><ul><li>左括号前无换行，后边换行</li><li>右括号前有换行，后边也有换行（if后紧跟的else除外，catch等除外）<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">    </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> MyClass() &#123;</span><br><span class="line">  <span class="meta">@Override</span> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (condition()) &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        something();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (ProblemException e) &#123;</span><br><span class="line">        recover();</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li></ul></li><li><p>空代码块</p><ul><li>左右括号紧跟或者换一行<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">// This is acceptable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothing</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This is equally acceptable</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">doNothingElse</span><span class="params">()</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul></li><li><p>缩进</p><ul><li>两个空格（目前习惯缩进四个空格）</li></ul></li><li>自动换行<ul><li>类限制，一行不能过长，限制为80或100字符</li><li>从非赋值运算符出断开，在符号前断开（比如+，它将位于下一行）</li><li>赋值运算符后断开</li><li>方法名或者构造函数名与左括号留在同一行</li><li>都好与前面的内容留在同一行</li><li>自动换行时，第一行后的每一行至少比第一行多缩进4个空格</li></ul></li><li>空行<ul><li>类内连续的成员之间：字段（可选）、构造函数、方法等</li><li>函数体中，语句的逻辑分组间使用空行</li></ul></li><li>水平空格<ul><li>保留字与紧随其后的<code>(</code>之间（如if, for等）</li><li>保留字与其前面的<code>}</code></li><li><code>{</code>前，例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>二元或三元运算符两侧</li><li><code>,</code> <code>:</code> <code>;</code>及<code>)</code>后</li><li>注释<code>//</code>后</li><li>数组初始化时，大括号内的空格是可选的<code>new int[] {5, 6}</code> 和 <code>new int[] { 5, 6 }</code> 都是可以的</li></ul></li><li>其他<ul><li>变量声明：一次只声明一个变量，需要时才声明，并尽量进行初始化</li></ul></li></ul><p>Reference：</p><ol><li><a href="https://google.github.io/styleguide/javaguide.html" target="_blank" rel="noopener">Google Java Style Guide</a></li></ol><h1 id="小技巧"><a href="#小技巧" class="headerlink" title="小技巧"></a>小技巧</h1><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = left + ((right - left) &gt;&gt; <span class="number">1</span>)   <span class="comment">// 二分法,注意便面的括号</span></span><br><span class="line"><span class="keyword">int</span> mid = (left + right) / <span class="number">2</span>           <span class="comment">// ！！！不要使用，因为如果left或right很大，二者的和可能溢出，但mid不会溢出</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**************************** 位运算 ****************************/</span></span><br><span class="line">(<span class="number">1</span> &lt;&lt; <span class="number">31</span>) - <span class="number">1</span>; <span class="comment">// 获取int型最大值，由于优先级关机，括号不可以省略</span></span><br><span class="line"><span class="number">1</span> &lt;&lt; <span class="number">31</span>;       <span class="comment">// 获取int型最小值</span></span><br><span class="line">(n &amp; <span class="number">1</span>) == <span class="number">1</span>;  <span class="comment">// 判断一个数的奇偶性</span></span><br><span class="line">(x ^ y) &gt;= <span class="number">0</span>   <span class="comment">// 判断x,y正负符号是否相同</span></span><br><span class="line">n &gt; <span class="number">0</span> ? (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> : <span class="keyword">false</span>;                     <span class="comment">//判断n是不是2的幂</span></span><br><span class="line">n &gt; <span class="number">0</span> &amp;&amp; (<span class="number">1162261467</span> % n) == <span class="number">0</span>;     <span class="comment">//1162261467 = 2 ^13//判断n是不是3的幂 </span></span><br><span class="line">n &gt; <span class="number">0</span> &amp;&amp; (n &amp; (n - <span class="number">1</span>)) == <span class="number">0</span> &amp;&amp; (n &amp; <span class="number">0x55555555</span>) != <span class="number">0</span>;   <span class="comment">//判断n是不是4的幂</span></span><br><span class="line">m &amp; (n - <span class="number">1</span>);           <span class="comment">// &lt;==&gt; m % (n - 1) 其中 n = 2 ^ k, k位正整数</span></span><br><span class="line">(n &gt;&gt; (m - <span class="number">1</span>)) &amp; <span class="number">1</span>;    <span class="comment">// 从低位到高位，取n的第m位</span></span><br><span class="line">n &amp; (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>)) == <span class="number">0</span><span class="comment">// 从低位到高位，取n的第m位 </span></span><br><span class="line">n | (<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>));    <span class="comment">// 从低位到高位，将n的第m位置1</span></span><br><span class="line">n &amp; ~(<span class="number">1</span> &lt;&lt; (m - <span class="number">1</span>));   <span class="comment">// 从低位到高位，将n的第m位置0</span></span><br><span class="line">Integer.bitCount(num); <span class="comment">// 统计每位1的个数       </span></span><br><span class="line">((<span class="number">1</span> &lt;&lt; i) &amp; num) == <span class="number">0</span>  <span class="comment">// 判断某一位是否为0</span></span><br><span class="line">num = ((<span class="number">1</span> &lt;&lt; i) | num) <span class="comment">// 设置某一位为1</span></span><br><span class="line">x &amp; (~<span class="number">0</span> &lt;&lt; n)          <span class="comment">// 将x最右边的n位清零</span></span><br><span class="line">x &amp; ((<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>)     <span class="comment">// 将最高位到i位（含）清零</span></span><br><span class="line">n &amp; (n - <span class="number">1</span>) == <span class="number">0</span>       <span class="comment">// 检查n是否为2的某次方，或者n是否为0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 统计正数c二进制位1的个数</span></span><br><span class="line"><span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; c != <span class="number">0</span>; c = c &amp; (c - <span class="number">1</span>)) &#123;</span><br><span class="line">    count++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 变量交换</span></span><br><span class="line">a ^= b;</span><br><span class="line">b ^= a;</span><br><span class="line">a ^= b;</span><br><span class="line"></span><br><span class="line"><span class="comment">// if(x == a) x = b; if(x == b) x = a;</span></span><br><span class="line">x = a ^ b ^ x;</span><br><span class="line"></span><br><span class="line">dp[i &amp; <span class="number">1</span>]   <span class="comment">//0,1循环</span></span><br><span class="line"><span class="comment">// 保留最低位的1，其他位都变为0</span></span><br><span class="line">flag &amp;= (-flag)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 输出</span></span><br><span class="line">String str = String.format(<span class="string">"%02d"</span>,num);   <span class="comment">// num不够两位则自动补全前面的0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断两个int数相加是否溢出</span></span><br><span class="line"><span class="keyword">if</span> ((a &gt; <span class="number">0</span> &amp;&amp; b &gt; <span class="number">0</span> &amp;&amp; a &gt; Integer.MAX_VALUE - b) </span><br><span class="line">  || (a &lt; <span class="number">0</span> &amp;&amp; b &lt; <span class="number">0</span> &amp;&amp; a &lt; Integer.MAX_VALUE - b)) &#123;</span><br><span class="line">    <span class="comment">// overflow</span></span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断一个元素至少出现两次</span></span><br><span class="line"><span class="keyword">if</span> (!once.add(key) &amp;&amp; more.add(key)) &#123;</span><br><span class="line">  <span class="comment">// Do Somthing</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="Linux-命令"><a href="#Linux-命令" class="headerlink" title="Linux 命令"></a>Linux 命令</h1><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">&gt; fileName  <span class="comment">#文件清空</span></span><br></pre></td></tr></table></figure><blockquote><p><a href="http://blog.csdn.net/zmazon/article/details/8262185" target="_blank" rel="noopener">常用位运算</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
    </entry>
    
    <entry>
      <title>动态规划——由实践总结经验</title>
      <link href="/2016/05/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
      <url>/2016/05/22/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;本科时候，为了考试对动态规划进行过一次恶补，但那时对动态规划理解不够。现在重新翻出来，经过两周多的整理，对其理解进一步加深。动态规划的核心在于将待求解问题分解为子问题，子问题的规模小于原问题，并且求解方法一致，但原问题的求解依赖于子问题，子问题之间往往不相互独立。典型特征就是，动态规划中所使用的递推公式。与之相比，分治法的核心在于将原问题规模缩小，分解为多个子问题，且各个子问题之间相互独立。</p><h1 id="基础题目"><a href="#基础题目" class="headerlink" title="基础题目"></a>基础题目</h1><h2 id="矩阵取数问题"><a href="#矩阵取数问题" class="headerlink" title="矩阵取数问题"></a>矩阵取数问题</h2><p><strong>问题描述</strong><br>一个N*N矩阵中有不同的正整数，经过这个格子，就能获得相应价值的奖励，从左上走到右下，只能向下向右走，求能够获得的最大价值。<br>例如：3 * 3的方格。<br>1 3 3<br>2 1 3<br>2 2 1<br>能够获得的最大价值为：11。<br><strong>输入</strong><br>第1行：N，N为矩阵的大小。(2 &lt;= N &lt;= 500)<br>第2 - N + 1行：每行N个数，中间用空格隔开，对应格子中奖励的价值。（1 &lt;= N[i] &lt;= 10000)<br><strong>输出</strong><br>输出能够获得的最大价值。<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 3</span><br><span class="line">2 1 3</span><br><span class="line">2 2 1</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">11</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; nums(n);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; dp(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row(n);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; maxRow(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)&#123;</span><br><span class="line">            <span class="built_in">cin</span> &gt;&gt; row[j];</span><br><span class="line">        &#125;</span><br><span class="line">        nums[i] = row;</span><br><span class="line">        dp[i] = maxRow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; maxRow(n + <span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    dp[n] = maxRow;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= n; j++)&#123;</span><br><span class="line">            dp[i][j] = max(dp[i - <span class="number">1</span>][j],dp[i][j - <span class="number">1</span>]) + nums[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt; dp[n][n]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最大子段和"><a href="#最大子段和" class="headerlink" title="最大子段和"></a>最大子段和</h2><p><strong>问题描述</strong><br>N个整数组成的序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续子段和的最大值。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。<br><strong>输入</strong><br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：N个整数（-10^9 &lt;= A[i] &lt;= 10^9）<br><strong>输出</strong><br>输出最大子段和。<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-2</span><br><span class="line">11</span><br><span class="line">-4</span><br><span class="line">13</span><br><span class="line">-5</span><br><span class="line">-2</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; cur;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> result = cur;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> pre = cur;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n;i++)&#123;</span><br><span class="line">       <span class="built_in">cin</span> &gt;&gt; cur;</span><br><span class="line">       <span class="keyword">if</span>(pre &gt; <span class="number">0</span>)&#123;</span><br><span class="line">           pre = pre + cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">else</span>&#123;</span><br><span class="line">           pre = cur;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">if</span>(pre &gt; result)&#123;</span><br><span class="line">           result = pre;</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; result&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最长公共子序列问题"><a href="#最长公共子序列问题" class="headerlink" title="最长公共子序列问题"></a>最长公共子序列问题</h2><p><strong>问题描述</strong><br>给出两个字符串A B，求A与B的最长公共子序列（子序列不要求是连续的）。<br>比如两个串为：<br>abcicba<br>abdkscab<br>ab是两个串的子序列，abc也是，abca也是，其中abca是这两个字符串最长的子序列。<br><strong>输入</strong><br>第1行：字符串A<br>第2行：字符串B<br>(A,B的长度 &lt;= 1000)<br><strong>输出</strong><br>输出最长的子序列，如果有多个，随意输出1个。<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abcicba</span><br><span class="line">abdkscab</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">abca</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;list&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> x;</span><br><span class="line">    <span class="keyword">int</span> y;</span><br><span class="line">    <span class="keyword">char</span> node = <span class="string">'\0'</span>;</span><br><span class="line">    <span class="keyword">int</span> maxLength = <span class="number">0</span>;</span><br><span class="line">&#125; DpNode;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">string</span> b;</span><br><span class="line">    <span class="built_in">std</span>:<span class="built_in">cin</span> &gt;&gt; a &gt;&gt;b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;DpNode&gt; &gt; dp(a.size() + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= a.size(); i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;DpNode&gt; dpRow(b.size() + <span class="number">1</span>);</span><br><span class="line">        dp[i] = dpRow;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.size(); i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= b.size(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>]) &#123;</span><br><span class="line">                dp[i][j].maxLength = dp[i - <span class="number">1</span>][j - <span class="number">1</span>].maxLength + <span class="number">1</span>;</span><br><span class="line">                dp[i][j].x = i - <span class="number">1</span>;</span><br><span class="line">                dp[i][j].y = j - <span class="number">1</span>;</span><br><span class="line">                dp[i][j].node = a[i - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (dp[i - <span class="number">1</span>][j].maxLength &gt; dp[i][j - <span class="number">1</span>].maxLength) &#123;</span><br><span class="line">                    dp[i][j].maxLength = dp[i - <span class="number">1</span>][j].maxLength;</span><br><span class="line">                    dp[i][j].x = i - <span class="number">1</span>;</span><br><span class="line">                    dp[i][j].y = j;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    dp[i][j].maxLength = dp[i][j - <span class="number">1</span>].maxLength;</span><br><span class="line">                    dp[i][j].x = i;</span><br><span class="line">                    dp[i][j].y = j - <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> x = a.size();</span><br><span class="line">    <span class="keyword">int</span> y = b.size();</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt; result;</span><br><span class="line">    <span class="keyword">int</span> xTemp;</span><br><span class="line">    <span class="keyword">while</span> (x != <span class="number">0</span> &amp;&amp; y != <span class="number">0</span>) &#123;</span><br><span class="line">        c = dp[x][y].node;</span><br><span class="line">        <span class="keyword">if</span> (c != <span class="string">'\0'</span>) &#123;</span><br><span class="line">            result.push_front(c);</span><br><span class="line">        &#125;</span><br><span class="line">        xTemp = x;</span><br><span class="line">        x = dp[xTemp][y].x;</span><br><span class="line">        y = dp[xTemp][y].y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">list</span>&lt;<span class="keyword">char</span>&gt;::iterator it = result.begin(); it != result.end(); it++) &#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; *it;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="编辑距离问题"><a href="#编辑距离问题" class="headerlink" title="编辑距离问题"></a>编辑距离问题</h2><p><strong>问题描述</strong><br>编辑距离，又称Levenshtein距离（也叫做Edit Distance），是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。<br>例如将kitten一字转成sitting：<br>sitten （k-&gt;s）<br>sittin （e-&gt;i）<br>sitting （-&gt;g）<br>所以kitten和sitting的编辑距离是3。俄罗斯科学家Vladimir Levenshtein在1965年提出这个概念。<br>给出两个字符串a,b，求a和b的编辑距离。<br><strong>输入</strong><br>第1行：字符串a(a的长度 &lt;= 1000)。<br>第2行：字符串b(b的长度 &lt;= 1000)。<br><strong>输出</strong><br>输出a和b的编辑距离。<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kitten</span><br><span class="line">sitting</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> a;</span><br><span class="line">    <span class="built_in">string</span> b;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; a &gt;&gt; b;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; dp(a.size() + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dpRow(b.size() + <span class="number">1</span>);</span><br><span class="line">    dp[<span class="number">0</span>] = dpRow;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= b.size();i++ )&#123;</span><br><span class="line">        dp[<span class="number">0</span>][i] = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= a.size();i++)&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dpRow(b.size() + <span class="number">1</span>);</span><br><span class="line">        dp[i] = dpRow;</span><br><span class="line">        dp[i][<span class="number">0</span>] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> minTemp;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; a.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; b.size();j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(a[i] == b[j])&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                minTemp = min(dp[i][j] + <span class="number">1</span>,dp[i][j + <span class="number">1</span>] + <span class="number">1</span>);</span><br><span class="line">                dp[i + <span class="number">1</span>][j + <span class="number">1</span>] = min(minTemp,dp[i + <span class="number">1</span>][j] + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;dp[a.size()][b.size()]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="最长单增子序列"><a href="#最长单增子序列" class="headerlink" title="最长单增子序列"></a>最长单增子序列</h2><p><strong>问题描述</strong><br>给出长度为N的数组，找出这个数组的最长递增子序列。(递增子序列是指，子序列的元素是递增的）<br>例如：5 1 6 8 2 4 5 10，最长递增子序列是1 2 4 5 10。<br><strong>输入</strong><br>第1行：1个数N，N为序列的长度(2 &lt;= N &lt;= 50000)<br>第2 - N + 1行：每行1个数，对应序列的元素(-10^9 &lt;= S[i] &lt;= 10^9)<br><strong>输出</strong><br>输出最长递增子序列的长度。<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">8</span><br><span class="line">5</span><br><span class="line">1</span><br><span class="line">6</span><br><span class="line">8</span><br><span class="line">2</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">10</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * maxs[x] 中记录了目前单调子序列中长度为x的所有子序列中，最后一个元素的最小值。</span></span><br><span class="line"><span class="comment"> * 比如当然有两个单调子序列长度为2: 1 3; 1 4。maxs[2] = 3</span></span><br><span class="line"><span class="comment"> * 代表了最优情况，因为元素越小继续延伸的潜力越大</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">updateMaxArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;maxs, <span class="keyword">int</span> newNum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> left = <span class="number">0</span>, right = maxs.size() - <span class="number">1</span>, mid = left + (right - left) / <span class="number">2</span>; left &lt;= right;) &#123;</span><br><span class="line">        <span class="keyword">if</span> (maxs[mid] &lt; newNum) &#123;</span><br><span class="line">            temp = mid;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (temp != maxs.size() - <span class="number">1</span>) &#123;</span><br><span class="line">        maxs[temp + <span class="number">1</span>] = newNum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        maxs.insert(maxs.begin() + temp + <span class="number">1</span>, newNum);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="keyword">int</span> cur;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxs(<span class="number">1</span>, INT_MIN);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cur;</span><br><span class="line">        updateMaxArray(maxs, cur);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (maxs.size() - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="0-1背包问题"><a href="#0-1背包问题" class="headerlink" title="0-1背包问题"></a>0-1背包问题</h2><p><strong>问题描述</strong><br>在N件物品取出若干件放在容量为W的背包里，每件物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br><strong>输入</strong><br>第1行，2个整数，N和W中间用空格隔开。N为物品的数量，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 10000)<br>第2 - N + 1行，每行2个整数，Wi和Pi，分别是物品的体积和物品的价值。(1 &lt;= Wi, Pi &lt;= 10000)<br><strong>输出</strong><br>输出可以容纳的最大价值。<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 5</span><br><span class="line">3 8</span><br><span class="line">4 9</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">14</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">101</span>][<span class="number">10001</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * dp[i][j] -&gt; 在前个物品中任意选取，容量不超过j的物品最大价值</span></span><br><span class="line"><span class="comment"> * dp[i][j] = dp[i-1][j] 第i个物品的重量大于j</span></span><br><span class="line"><span class="comment"> * dp[i][j] = max(dp[i-1][j],dp[i-1][j-w[i]] + p[i]) 否则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; w(n + <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; p(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; w[i] &gt;&gt; p[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= m;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(w[i] &lt;= j)&#123;</span><br><span class="line">                dp[i][j] = max(dp[i - <span class="number">1</span>][j],dp[i - <span class="number">1</span>][j - w[i]] + p[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[n][m] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="正整数分组"><a href="#正整数分组" class="headerlink" title="正整数分组"></a>正整数分组</h2><p><strong>问题描述</strong><br>将一堆正整数分为2组，要求2组的和相差最小。<br>例如：1 2 3 4 5，将1 2 4分为1组，3 5分为1组，两组和相差1，是所有方案中相差最少的。<br><strong>输入</strong><br>第1行：一个数N，N为正整数的数量。<br>第2 - N+1行，N个正整数。<br>(N &lt;= 100, 所有正整数的和 &lt;= 10000)<br><strong>输出</strong><br>输出这个最小差<br><strong>输入示例</strong></p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">5</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">1</span><br></pre></td></tr></table></figure></p><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * f[i][j] -&gt; 在前i个数中选取一些数，总和不超过j的最大值</span></span><br><span class="line"><span class="comment"> * f[i][j] = f[i-1][j]  第i个数大于j</span></span><br><span class="line"><span class="comment"> * f[i][j] = max(f[i - 1][j],f[i - 1][j - nums[i - 1]] + nums[i - 1]) 否则</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums(n);</span><br><span class="line">    <span class="keyword">int</span> total = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; nums[i];</span><br><span class="line">        total = total+ nums[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> half = total / <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; f(n + <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; temp(half + <span class="number">1</span>);</span><br><span class="line">        f[i] = temp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt;::iterator fIter = f.begin();</span><br><span class="line">    fill((*fIter).begin(),(*fIter).end(),<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= half;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i - <span class="number">1</span>] &gt; j)&#123;</span><br><span class="line">                f[i][j] = f[i - <span class="number">1</span>][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                f[i][j] = max(f[i - <span class="number">1</span>][j],f[i - <span class="number">1</span>][j - nums[i - <span class="number">1</span>]] + nums[i - <span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; (total - <span class="number">2</span>*f[n][half])  &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="进阶题目"><a href="#进阶题目" class="headerlink" title="进阶题目"></a>进阶题目</h1><h2 id="最大子矩阵和"><a href="#最大子矩阵和" class="headerlink" title="最大子矩阵和"></a>最大子矩阵和</h2><p><strong>问题描述</strong><br>一个M*N的矩阵，找到此矩阵的一个子矩阵，并且这个子矩阵的元素的和是最大的，输出这个最大的值。<br>例如：3*3的矩阵：<br>-1 3 -1<br>2 -1 3<br>-3 1 2<br>和最大的子矩阵是：<br>3 -1<br>-1 3<br>1 2<br><strong>输入</strong><br>第1行：M和N，中间用空格隔开（2 &lt;= M,N &lt;= 500)。<br>第2 - N + 1行：矩阵中的元素，每行M个数，中间用空格隔开。(-10^9 &lt;= M[i] &lt;= 10^9)<br><strong>输出</strong><br>输出和的最大值。如果所有数都是负数，就输出0。<br><strong>输入示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 3</span><br><span class="line">-1 3 -1</span><br><span class="line">2 -1 3</span><br><span class="line">-3 1 2</span><br></pre></td></tr></table></figure></p><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">7</span><br></pre></td></tr></table></figure></p><p><strong>代码说明</strong><br>这道题目与基础题目中的最大子段和有些像，但本题是二维空间。但可以通过一些手段将其转化为一维空间。<br>设想，整个矩阵有3行，最大子矩阵可能的行数1/2/3; 矩阵数组为a[i][j]:</p><ul><li>矩阵行数为1：分别求第一行、第二行、第三行的最大子段和max1,max2,max3,那么max(max1,max2,max3)即为最大子矩阵和</li><li>矩阵行数为2：最大子矩阵出现在第1-2行或第2-3行，只有这两种情况。如果有一个一维数组total:<ul><li>total[k] = a[0][k] + a[1][k] total最大字段和max1</li><li>total[k] = a[1][k] + a[2][k] total最大字段和max2</li><li>那么max = max(max1,max2)即为最大子矩阵和</li></ul></li><li>矩阵行数为3：最大子矩阵出现在第1-3行，只有一种情况。如果有一个一维数组total:<ul><li>total[k] = a[0][k] + a[1][k] + a[2][k] total最大字段和max</li><li>那么max即为最大子矩阵和</li></ul></li></ul><p>通过这个例子是不是可以感受到一些启发？将 <strong>第i行到第j行压缩为一行(求和),即可以转化为求解最大子段和,此时可获得行数为(j-i+1)时的最大子矩阵和</strong><br>假设n*m的矩阵的最大子矩阵的行数为i(1&lt;=i&lt;=n) 如果有一个一维数组total:</p><ul><li>total[k] = a[0][k] + … +a[i-1][k] total最大字段和max1</li><li>…</li><li>total[k] = a[n-i][k] + … + a[n - 1][k] total最大字段和max..</li><li>那么max = max(max1,…)即为最大子矩阵和</li></ul><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* 求最大字段和</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxSubSequence</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (arr.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">int</span> maxSub = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">int</span> temp = arr[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; arr.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (temp &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                temp = temp + arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                temp = arr[i];</span><br><span class="line">            &#125;</span><br><span class="line">            maxSub = max(maxSub, temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxSub;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; m &gt;&gt; n;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//初始化</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; nums(n);</span><br><span class="line">    <span class="comment">// total[i][k] = nums[0][k] + ... + nums[i][k];</span></span><br><span class="line">    <span class="comment">// 所以nums[i..j][k] = total[j][k]-total[i - 1][k]</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &gt; total(n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row(m);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; totalRow(m);</span><br><span class="line">        <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; row[j];</span><br><span class="line">                totalRow[j] = row[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; m; j++) &#123;</span><br><span class="line">                <span class="built_in">cin</span> &gt;&gt; row[j];</span><br><span class="line">                totalRow[j] = total[i - <span class="number">1</span>][j] + row[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        nums[i] = row;</span><br><span class="line">        total[i] = totalRow;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> maxSub = INT_MIN;</span><br><span class="line">    <span class="comment">// 最大子矩阵行数为 i</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; n; j++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; m; k++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (i == <span class="number">0</span>) &#123;</span><br><span class="line">                    result[k] = total[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    result[k] = total[j][k] - total[i - <span class="number">1</span>][k];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">int</span> maxTemp = maxSubSequence(result);</span><br><span class="line">            <span class="keyword">if</span> (maxTemp &gt; maxSub) &#123;</span><br><span class="line">                maxSub = maxTemp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; maxSub &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>参考</strong></p><blockquote><p><a href="http://blog.csdn.net/beiyeqingteng/article/details/7056687" target="_blank" rel="noopener">http://blog.csdn.net/beiyeqingteng/article/details/7056687</a></p></blockquote><h2 id="循环数组最大字段和"><a href="#循环数组最大字段和" class="headerlink" title="循环数组最大字段和"></a>循环数组最大字段和</h2><p><strong>问题描述</strong><br>N个整数组成的循环序列a[1],a[2],a[3],…,a[n]，求该序列如a[i]+a[i+1]+…+a[j]的连续的子段和的最大值（循环序列是指n个数围成一个圈，因此需要考虑a[n-1],a[n],a[1],a[2]这样的序列）。当所给的整数均为负数时和为0。<br>例如：-2,11,-4,13,-5,-2，和最大的子段为：11,-4,13。和为20。<br><strong>输入</strong><br>第1行：整数序列的长度N（2 &lt;= N &lt;= 50000)<br>第2 - N+1行：N个整数 (-10^9 &lt;= S[i] &lt;= 10^9)<br><strong>输出</strong><br>输出循环数组的最大子段和。<br><strong>输入示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">6</span><br><span class="line">-2</span><br><span class="line">11</span><br><span class="line">-4</span><br><span class="line">13</span><br><span class="line">-5</span><br><span class="line">-2</span><br></pre></td></tr></table></figure></p><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure></p><p><strong>代码说明</strong></p><ul><li>如果最大字段和不是跨越数组头尾的情况，即为普通的最大字段和求解问题。</li><li>如果最大子段和跨越数组头尾，即 arr[j…n-1] + arr[0…i];易得子段arr[i+1…j-1] 为最小子段和，这种情况也就可以转化为 total[0…n-1] - minSubSequence</li><li>二者取max即为循环数组最大字段和</li></ul><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;climits&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    ll cur,preMax,preMin;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; preMax;</span><br><span class="line">    ll total = preMax;</span><br><span class="line">    ll maxSub = preMax;</span><br><span class="line">    ll minSub = preMax;</span><br><span class="line">    preMin = preMax;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)&#123;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; cur;</span><br><span class="line">        total = total + cur;</span><br><span class="line">        <span class="keyword">if</span>(preMax &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            preMax = preMax + cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            preMax = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(preMin &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            preMin = preMin + cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            preMin = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        maxSub = max(maxSub,preMax);</span><br><span class="line">        minSub = min(minSub,preMin);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; max(maxSub,total - minSub) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h2><p><strong>问题描述</strong><br>有N种物品，每种物品的数量为C1，C2……Cn。从中任选若干件放在容量为W的背包里，每种物品的体积为W1，W2……Wn（Wi为整数），与之相对应的价值为P1,P2……Pn（Pi为整数）。求背包能够容纳的最大价值。<br><strong>输入</strong><br>第1行，2个整数，N和W中间用空格隔开。N为物品的种类，W为背包的容量。(1 &lt;= N &lt;= 100，1 &lt;= W &lt;= 50000)<br>第2 - N + 1行，每行3个整数，Wi，Pi和Ci分别是物品体积、价值和数量。(1 &lt;= Wi, Pi &lt;= 10000， 1 &lt;= Ci &lt;= 200)<br><strong>输出</strong><br>输出可以容纳的最大价值。<br><strong>输入示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">3 6</span><br><span class="line">2 2 5</span><br><span class="line">3 3 8</span><br><span class="line">1 4 1</span><br></pre></td></tr></table></figure></p><p><strong>输出示例</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">9</span><br></pre></td></tr></table></figure></p><p><strong>代码说明</strong></p><ul><li>将多重背包分解为0-1背包</li><li>利用二进制的思想，任何一个数都可以由2的幂次表示：N = 1 + 2 + 4 + … + 2^i + (left);</li><li>即每个物品都可以被分解。假设物品的数量为14,则从14个物品中任取N个物品都可以转化为由以下物品组合(以下物品在每次组合中只能取一次)<ul><li>1^0 重量是Wi，体积是Vi</li><li>2^2 重量是2 * Wi , 体积是2 * Vi</li><li>2^3 重量是4 * Wi , 体积是4 * Vi</li><li>14 - (1+2+4) 重量是7 * Wi , 体积是7 * Vi</li></ul></li><li>分解完成后，再利用0-1背包思路求解</li></ul><p><strong>示例代码</strong><br><figure class="highlight cpp"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> w;</span><br><span class="line">    <span class="keyword">int</span> p;</span><br><span class="line">&#125; Thing;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,w;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n &gt;&gt; w;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//分解</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;Thing&gt; things;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n;i++)&#123;</span><br><span class="line">        Thing thing;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; thing.w &gt;&gt; thing.p;</span><br><span class="line">        <span class="keyword">int</span> num;</span><br><span class="line">        <span class="built_in">cin</span> &gt;&gt; num;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">1</span>; k &lt;= num;k &lt;&lt;= <span class="number">1</span>)&#123;</span><br><span class="line">            Thing temp;</span><br><span class="line">            temp.w = k * thing.w;</span><br><span class="line">            temp.p = k * thing.p;</span><br><span class="line">            num -= k;</span><br><span class="line">            things.push_back(temp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(num &gt; <span class="number">0</span>)&#123;</span><br><span class="line">            thing.w = num * thing.w;</span><br><span class="line">            thing.p = num * thing.p;</span><br><span class="line">            things.push_back(thing);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//0-1背包</span></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt; &gt; dp(things.size() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;(w + <span class="number">1</span>,<span class="number">0</span>));</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; things.size();i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= w;j++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(j &lt; things[i].w)&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = dp[i][j];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                dp[i + <span class="number">1</span>][j] = max(dp[i][j],dp[i][j - things[i].w] + things[i].p);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; dp[things.size()][w]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h1 id="Reference"><a href="#Reference" class="headerlink" title="Reference"></a>Reference</h1><blockquote><p>1.<a href="http://www.51nod.com/tutorial/index.html#!tutorialId=1" target="_blank" rel="noopener">动态规划基础篇</a><br>2.<a href="http://www.51nod.com/tutorial/index.html#!tutorialId=2" target="_blank" rel="noopener">动态规划入门篇</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 算法 </tag>
            
            <tag> 动态规划 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>编程之美复赛总结</title>
      <link href="/2016/05/18/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E5%A4%8D%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
      <url>/2016/05/18/%E7%BC%96%E7%A8%8B%E4%B9%8B%E7%BE%8E%E5%A4%8D%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;上周参加编程之美复赛，在和两个小伙伴的共同努力下，最终复赛取得了第22名的成绩，很遗憾没有进入决赛。但在这次比赛中，也学到了许多东西，在这里总结一下。</p><h1 id="赛题介绍"><a href="#赛题介绍" class="headerlink" title="赛题介绍"></a>赛题介绍</h1><p>Microsoft Academic Graph (MAG) is a large heterogeneous graph containing entities such as authors, papers, journals, conferences and relations between them. Microsoft provides <a href="https://www.microsoft.com/cognitive-services/en-us/academic-knowledge-api" target="_blank" rel="noopener">Academic Knowledge API</a> for this contest. The Entity attributes are defined <a href="https://www.microsoft.com/cognitive-services/en-us/academic-knowledge-api/documentation/EntityAttributes" target="_blank" rel="noopener">here</a>.</p><p>Participants are supposed to provide a REST service endpoint that can find all the 1-hop, 2-hop, and 3-hop graph paths connecting a given pair of entity identifiers in MAG. The given pair of entity identifiers could be [Id, Id], [Id, AA.AuId], [AA.AuId, Id], [AA.AuId, AA.AuId]. Each node of a path should be one of the following identifiers: Id, F.Fid, J.JId, C.CId, AA.AuId, AA.AfId. Possible edges (a pair of adjacent nodes) of a path are:<br><img src="编程之美复赛总结/bop2016-1.png" alt="1 - 节点间指向关系说明"><br>For each test case, the REST service endpoint will receive a JSON array via HTTP with a pair of entity identifiers, where the identifiers are 64-bit integers, e.g. [123, 456]. The service endpoint needs to respond with a JSON array within 300 seconds. The response JSON array consists of a list of graph paths in the form of [path1, path2, …, pathn], where each path is an array of entity identifiers. For example, if your program finds one 1-hop paths, two 2-hop paths, and one 3-hop paths, the results may look like this: [[123,456], [123,2,456], [123,3,456], [123,4,5,456]]. For a path such as [123,4,5,456], the integers are the identifiers of the entities on the path. After receiving the response, the evaluator will wait for a random period of time before sending the next requests.</p><h1 id="赛题分析"><a href="#赛题分析" class="headerlink" title="赛题分析"></a>赛题分析</h1><p><strong>简单总结：</strong>赛题的核心问题在于，寻找从给定的起点到给定的终点的路径。其中起点和终点可以是论文Id或者作者AuId,路径中的节点间指向关系如上图所示，路径的长度为小于或等于3。</p><h2 id="初始阶段"><a href="#初始阶段" class="headerlink" title="初始阶段"></a>初始阶段</h2><p>&emsp;&emsp;初始阶段，我们我们试图从起点开始，根据图1的节点关系从前向后拓展，直至找到终结点或跳数超过限制。这是一种“大一统”的算法，如果存在可行方案，当跳数限制修改时，此算法仍旧实用。为此我们绘制了如下状态转移图（由于时间有限，图中可能有某些细节存在问题）：<br><img src="bop2016-first_design-1.png" alt=""><br><img src="bop2016-first_design-2.png" alt="2 - 初始阶段_状态转移示意图"><br>&emsp;&emsp;经过初步设计，我们根据这个示意图编写出了第一版的代码，然而跑出来的结果却让人很不满意，有些测试用例根本没有计算出结果或者计算超时。于是，我们开始讨论原因以及解决方案。  </p><p><strong>主要原因：</strong>当我们以id或auid为查询条件查询时，获得的数据量并不大，但当我们以FId(研究领域Id)、JId(期刊Id)、Cid(会议Id)为查询条件时，获取的数据量确实巨大的。大到我们根本无法处理。所以才会出现无法继续探路的情况。<br><strong>解决方案</strong><br>从两端出发，而不是单纯的从一端出发，即从start和end同时向中间汇聚。不去进行FId、JId、FId的查询。</p><h2 id="进阶阶段"><a href="#进阶阶段" class="headerlink" title="进阶阶段"></a>进阶阶段</h2><p>&emsp;&emsp;根据从两端出发的指导思想，以减少请求次数为设计目标，分别为Id-Id/Id-AuId/AuId-Id/AuId-AuId四种情况进行了如下设计：<br><img src="id-id.png" alt=""><br><img src="id-auid.png" alt=""><br><img src="auid-id.png" alt=""><br><img src="auid-auid.png" alt="3 - 进阶阶段_状态转移示意图"><br>&emsp;&emsp;经过这次设计，整个思路就非常清晰了，自然程序也就水到渠成。</p><h1 id="项目工程和管理相关内容"><a href="#项目工程和管理相关内容" class="headerlink" title="项目工程和管理相关内容"></a>项目工程和管理相关内容</h1><h2 id="项目架构"><a href="#项目架构" class="headerlink" title="项目架构"></a>项目架构</h2><ul><li>RESTFul架构：选择SpringMVC框架作为RESTFul架构实现方式。</li><li>JSON解析：FastJSON</li><li>Http请求：Apache HttpClient</li><li>Web服务器：Tomcat</li><li>项目构建：Maven</li></ul><h2 id="项目优化"><a href="#项目优化" class="headerlink" title="项目优化"></a>项目优化</h2><ul><li>多线程优化：采用CachedThreadPool线程池对程序优化，实验发现，CachedThreadPool要优于FixedThreadPool。</li><li>Http请求优化：这部分有所欠缺，由于疏忽，这部分并未进行优化，可以建立TCP长连接，以减少连接创建消耗。</li></ul><h2 id="项目成员交流相关内容"><a href="#项目成员交流相关内容" class="headerlink" title="项目成员交流相关内容"></a>项目成员交流相关内容</h2><ul><li>SVN：进行代码同步</li><li>OneNote：进行文档同步和交流</li><li>WeChat/QQ：进行即时通信</li></ul><h2 id="项目代码"><a href="#项目代码" class="headerlink" title="项目代码"></a>项目代码</h2><p><a href="https://github.com/ZongWenlong/AcademicSearch" target="_blank" rel="noopener">AcademicSearch</a></p><h2 id="项目总结"><a href="#项目总结" class="headerlink" title="项目总结"></a>项目总结</h2><ul><li>盲目设计、盲目开发：在比赛开始阶段，对赛题分析不够清晰，浪费了很多时间。比如：根据FId查询会产生大量无用结果，这个问题，可以通过简单的测试就可以发现，但我们在初期并未察觉。</li><li>Just do it：原本在项目开始时，我们就意识到请求连接部分就是一个优化内容，但由于我们后期的疏忽，直到比赛结束我们也没有实际进行优化。</li><li>团队精神很重要：感谢两位小伙伴。比赛过程中大家一起讨论问题，一起解决问题，相互激发灵感，优势互补。   </li></ul><p>&emsp;&emsp;比赛结束了，遗憾的是没能进入决赛，幸运的是认识了两个小伙伴，并在比赛中学到了许多东西，蛮好。<br>&emsp;&emsp;Never give up! Be more confident!</p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 多线程 </tag>
            
            <tag> 图搜索 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Something about Hexo（持续更新）</title>
      <link href="/2016/05/15/Something-about-Hexo/"/>
      <url>/2016/05/15/Something-about-Hexo/</url>
      
        <content type="html"><![CDATA[<p>记录Hexo 使用的使用技巧，并会持续更新</p><h2 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h2><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new [layout] &lt;title&gt;  <span class="comment">#新建一篇文章</span></span><br><span class="line">hexo generate              <span class="comment">#生成静态文章</span></span><br><span class="line">hexo generate -d           <span class="comment">#文件生成后立即部署</span></span><br><span class="line">hexo server                <span class="comment">#启动服务器</span></span><br><span class="line">hexo server -p [port]      <span class="comment">#更改服务端口</span></span><br><span class="line">hexo deploy                <span class="comment">#部署网站</span></span><br><span class="line"></span><br><span class="line">hexo new draft &lt;filename&gt; <span class="comment">#新建草稿 </span></span><br><span class="line">hexo server --drafts       <span class="comment">#预览草稿</span></span><br><span class="line">hexo publish [layout] &lt;filename&gt;  <span class="comment">#发布草稿为文章</span></span><br></pre></td></tr></table></figure><h2 id="主题安装"><a href="#主题安装" class="headerlink" title="主题安装"></a>主题安装</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/tufu9441/maupassant-hexo.git themes/maupassant</span><br><span class="line">npm install hexo-renderer-jade --save</span><br><span class="line">npm install hexo-renderer-sass --save</span><br></pre></td></tr></table></figure><h2 id="Maupassant配置修改"><a href="#Maupassant配置修改" class="headerlink" title="Maupassant配置修改"></a>Maupassant配置修改</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">theme/maupassant/source/css/style.scss  #显示的css配置</span><br></pre></td></tr></table></figure><h2 id="Problems"><a href="#Problems" class="headerlink" title="Problems"></a>Problems</h2><p><strong>Problem-1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">TypeError: Cannot set property &apos;lastIndex&apos; of undefined</span><br><span class="line">    at highlight (E:\workspaces\Dropbox\Hexo\node_modules\highlight.js\lib\highlight.js:471:35)</span><br><span class="line">    at E:\workspaces\Dropbox\Hexo\node_modules\highlight.js\lib\highlight.js:524:21</span><br><span class="line">    at Array.forEach (native)</span><br><span class="line">    at Object.highlightAuto (E:\workspaces\Dropbox\Hexo\node_modules\highlight.js\lib\highlight.js:520:20)</span><br><span class="line">    at highlight (E:\workspaces\Dropbox\Hexo\node_modules\hexo-util\lib\highlight.js:98:19)</span><br><span class="line">    at highlightUtil (E:\workspaces\Dropbox\Hexo\node_modules\hexo-util\lib\highlight.js:21:14)</span><br><span class="line">    at E:\workspaces\Dropbox\Hexo\node_modules\hexo\lib\plugins\filter\before_post_render\backtick_code_block.js:49:15</span><br><span class="line">    at String.replace (native)</span><br><span class="line">    at Hexo.backtickCodeBlock (E:\workspaces\Dropbox\Hexo\node_modules\hexo\lib\plugins\filter\before_post_render\backti</span><br><span class="line">ck_code_block.js:15:31)</span><br><span class="line">    at Hexo.tryCatcher (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at E:\workspaces\Dropbox\Hexo\node_modules\hexo\lib\extend\filter.js:68:35</span><br><span class="line">    at tryCatcher (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Object.gotValue (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\reduce.js:145:18)</span><br><span class="line">    at Object.gotAccum (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\reduce.js:134:25)</span><br><span class="line">    at Object.tryCatcher (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\promise.js:503:31)</span><br><span class="line">    at Promise._settlePromise (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\promise.js:560:18)</span><br><span class="line">    at Promise._settlePromiseCtx (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\promise.js:597:10)</span><br><span class="line">    at Async._drainQueue (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\async.js:131:12)</span><br><span class="line">    at Async._drainQueues (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\async.js:136:10)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\async.</span><br><span class="line">js:16:14)</span><br><span class="line">    at processImmediate [as _immediateCallback] (timers.js:383:17)</span><br><span class="line">FATAL Cannot set property &apos;lastIndex&apos; of undefined</span><br><span class="line">TypeError: Cannot set property &apos;lastIndex&apos; of undefined</span><br><span class="line">    at highlight (E:\workspaces\Dropbox\Hexo\node_modules\highlight.js\lib\highlight.js:471:35)</span><br><span class="line">    at E:\workspaces\Dropbox\Hexo\node_modules\highlight.js\lib\highlight.js:524:21</span><br><span class="line">    at Array.forEach (native)</span><br><span class="line">    at Object.highlightAuto (E:\workspaces\Dropbox\Hexo\node_modules\highlight.js\lib\highlight.js:520:20)</span><br><span class="line">    at highlight (E:\workspaces\Dropbox\Hexo\node_modules\hexo-util\lib\highlight.js:98:19)</span><br><span class="line">    at highlightUtil (E:\workspaces\Dropbox\Hexo\node_modules\hexo-util\lib\highlight.js:21:14)</span><br><span class="line">    at E:\workspaces\Dropbox\Hexo\node_modules\hexo\lib\plugins\filter\before_post_render\backtick_code_block.js:49:15</span><br><span class="line">    at String.replace (native)</span><br><span class="line">    at Hexo.backtickCodeBlock (E:\workspaces\Dropbox\Hexo\node_modules\hexo\lib\plugins\filter\before_post_render\backti</span><br><span class="line">ck_code_block.js:15:31)</span><br><span class="line">    at Hexo.tryCatcher (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Hexo.&lt;anonymous&gt; (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\method.js:15:34)</span><br><span class="line">    at E:\workspaces\Dropbox\Hexo\node_modules\hexo\lib\extend\filter.js:68:35</span><br><span class="line">    at tryCatcher (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Object.gotValue (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\reduce.js:145:18)</span><br><span class="line">    at Object.gotAccum (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\reduce.js:134:25)</span><br><span class="line">    at Object.tryCatcher (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\util.js:16:23)</span><br><span class="line">    at Promise._settlePromiseFromHandler (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\promise.js:503:31)</span><br><span class="line">    at Promise._settlePromise (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\promise.js:560:18)</span><br><span class="line">    at Promise._settlePromiseCtx (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\promise.js:597:10)</span><br><span class="line">    at Async._drainQueue (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\async.js:131:12)</span><br><span class="line">    at Async._drainQueues (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\async.js:136:10)</span><br><span class="line">    at Immediate.Async.drainQueues [as _onImmediate] (E:\workspaces\Dropbox\Hexo\node_modules\bluebird\js\release\async.</span><br><span class="line">js:16:14)</span><br><span class="line">    at processImmediate [as _immediateCallback] (timers.js:383:17)</span><br></pre></td></tr></table></figure></p><p><strong>Solution-1</strong><br><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">set auto_detect(in _config.yml) to false solved my problem.</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>OSCache分布式集群配置</title>
      <link href="/2015/08/01/OSCache%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/"/>
      <url>/2015/08/01/OSCache%E5%88%86%E5%B8%83%E5%BC%8F%E9%9B%86%E7%BE%A4%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<p>&emsp;&emsp;之前在IBM实习时，由于licence的原因，项目使用OScCache进行数据缓存。单机部署项目测试时，未出现什么问题，但多机测试时出现了问题：OSCache频繁刷新，缓存效果下降。由于OSCcache已经停止更新，OSCache集群方面资料较少，通过一周的学习和探索，终于找到了解决方案。</p><h1 id="OSCache简介"><a href="#OSCache简介" class="headerlink" title="OSCache简介"></a>OSCache简介</h1><ul><li>缓存任何对象</li><li>永久缓存，缓存持久化处理</li><li>缓存记录的过期</li><li>支持集群（需要额外配置）<div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/OSCache-cluster.png?raw=true" width="300"><br></div></li></ul><h1 id="OSCache-集群支持介绍"><a href="#OSCache-集群支持介绍" class="headerlink" title="OSCache 集群支持介绍"></a>OSCache 集群支持介绍</h1><p>&emsp;&emsp;OScache自身不具备集群通信能力，它他需要借助第三方通讯工具来实现集群缓存数据同步。下图所示是OScache集群相关的Java类，其中</p><ul><li>AbstractBroadcastingListener负责缓存同步事件的下发和处理</li><li>类ClusterNotification为组播消息体（Bean）</li><li>类JavaGroupsBroadcastingListener/ JMS10BroadcastingListening/ JMSBroadcastingListening由OSCache官方提供，利用JGroups通信框架或JMS通信框架的组播能力实现OSCache的缓存数据同步需求。</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-2.png?raw=true" width="300"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-3.png?raw=true" width="350"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-4.png?raw=true" width="500"><br></div><h1 id="OOSCache集群同步解决方案"><a href="#OOSCache集群同步解决方案" class="headerlink" title="OOSCache集群同步解决方案"></a>OOSCache集群同步解决方案</h1><p>1. OSCache+JGroups（本文介绍）</p><ol start="2"><li>OSCache+JMS（略）</li><li>OSCache+其他的通信框架（略）<div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-5.png?raw=true" width="500"><br></div><br>下面介绍OSCache+JGroups的配置方式<br><div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-6.png?raw=true" width="600"><br></div></li></ol><p>JavaGroupsBroadcastingListener</p><ul><li>initialize(Cache cache, Config config)  – 加载通信基本配置</li><li>sendNotification(ClusterNotification message) – 发送组播消息</li><li>handleNotification(Serializable serializable)  –  处理接收到的接收组播消息</li></ul><h2 id="默认配置"><a href="#默认配置" class="headerlink" title="默认配置"></a>默认配置</h2><ol><li>我使用的Jar包：jgroups-2.12.3.Final.jar(3.*以上JGroups不支持)，concurrent-1.3.4.jar，oscache-2.4.1.jar，log4j-1.2.17.jar，commons-logging-1.2.jar(OScache中使用的log)</li><li>添加文件src/oscache.properties（log4j.properties也可以放在src目录下），添加以下内容<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">cache.event.listeners=com.opensymphony.oscache.plugins.clustersupport.JavaGroupsBroadcastingListener  -- 组播事件监听器</span><br><span class="line">cache.memory=<span class="literal">true</span> -- 是否使用内存</span><br><span class="line">cache.blocking=<span class="literal">true</span> -- 是否同步</span><br><span class="line">cache.cluster.properties=</span><br><span class="line">UDP(mcast_addr=231.12.21.132;mcast_port=45566;ip_ttl=32;\</span><br><span class="line">mcast_send_buf_size=150000;mcast_recv_buf_size=80000):\</span><br><span class="line">PING(timeout=2000;num_initial_members=3):\</span><br><span class="line">MERGE2(min_interval=5000;max_interval=10000):\</span><br><span class="line">FD_SOCK:VERIFY_SUSPECT(timeout=1500):\</span><br><span class="line">pbcast.NAKACK(gc_lag=50;retransmit_timeout=300,600,1200,2400,4800;max_xmit_size=8192):\</span><br><span class="line">UNICAST(timeout=300,600,1200,2400):\</span><br><span class="line">pbcast.STABLE(desired_avg_gossip=20000):\</span><br><span class="line">FRAG(frag_size=8096;down_thread=<span class="literal">false</span>;up_thread=<span class="literal">false</span>):\</span><br><span class="line">pbcast.GMS(join_timeout=5000;join_retry_timeout=2000;shun=<span class="literal">false</span>;print_local_addr=<span class="literal">true</span>)</span><br><span class="line">cache.cluster.multicast.ip=231.12.21.132 -- 组播IP</span><br></pre></td></tr></table></figure></li></ol><h3 id="默认配置的问题："><a href="#默认配置的问题：" class="headerlink" title="默认配置的问题："></a>默认配置的问题：</h3><p>刷新动作（数据库增删改）同步，但缓存数据不同步。</p><div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-7.png?raw=true" width="600"><br></div><h3 id="缓存数据不同步原因："><a href="#缓存数据不同步原因：" class="headerlink" title="缓存数据不同步原因："></a>缓存数据不同步原因：</h3><p>OSCache所提供的AbstractBroadcastingListener类中只有刷新消息的发送、接收和处理逻辑，无实时同步逻辑。</p><div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-8.png?raw=true" width="500"><br></div><h2 id="缓存数据同步配置"><a href="#缓存数据同步配置" class="headerlink" title="缓存数据同步配置"></a>缓存数据同步配置</h2><ol><li><p>增加类</p><ul><li><p>JavaGroupsSyncBroadcastingListener</p><ul><li>实现方法（发消息）：<ul><li>cacheEntryAdded</li><li>cacheEntryRemoved</li><li>cacheEntryUpdated</li></ul></li><li>扩充方法（收消息）：<ul><li>handleClusterNotification</li></ul></li></ul></li><li>CacheConstants  –  添加事件类型常量</li><li>SerialCacheEvent  – 可序列化的事件类</li></ul></li><li><p>修改配置文件oscache.properties：</p></li></ol><ul><li>cache.event.listeners=JavaGroupsSyncBroadcastingListener（Package完整路径）</li></ul><div align="center"><br><img src="https://raw.githubusercontent.com/ZongWenlong/ZongWenlong.github.io/master/image/oscache-9.png?raw=true" width="500"><br></div><h3 id="代码列表"><a href="#代码列表" class="headerlink" title="代码列表"></a>代码列表</h3><ul><li><p>JavaGroupsSyncBroadcastingListener</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.Date;  </span><br><span class="line"><span class="keyword">import</span> java.util.Set;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.Log;  </span><br><span class="line"><span class="keyword">import</span> org.apache.commons.logging.LogFactory;  </span><br><span class="line">  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.oscache.base.events.CacheEntryEvent;  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.oscache.plugins.clustersupport.ClusterNotification;  </span><br><span class="line"><span class="keyword">import</span> com.opensymphony.oscache.plugins.clustersupport.JavaGroupsBroadcastingListener;  </span><br><span class="line">  </span><br><span class="line"><span class="comment">/** </span></span><br><span class="line"><span class="comment">* 自定义BroadCastingListener,重写父类方法。 </span></span><br><span class="line"><span class="comment">*/</span>  </span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaGroupsSyncBroadcastingListener</span> <span class="keyword">extends</span>  </span></span><br><span class="line"><span class="class">          <span class="title">JavaGroupsBroadcastingListener</span> </span>&#123;  </span><br><span class="line">     <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span> Log log = LogFactory  </span><br><span class="line">               .getLog(JavaGroupsBroadcastingListenerImpl.class);  </span><br><span class="line">  </span><br><span class="line">     <span class="meta">@SuppressWarnings</span>(<span class="string">"deprecation"</span>)  </span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handleClusterNotification</span><span class="params">(ClusterNotification message)</span> </span>&#123;  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (cache == <span class="keyword">null</span>) &#123;  </span><br><span class="line">               log.warn(<span class="string">"A cluster notification ("</span>  </span><br><span class="line">                         + message  </span><br><span class="line">                         + <span class="string">") was received, but no cache is registered on this machine. Notification ignored."</span>);  </span><br><span class="line">  </span><br><span class="line">               <span class="keyword">return</span>;  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">if</span> (log.isInfoEnabled()) &#123;  </span><br><span class="line">               log.info(<span class="string">"Cluster notification ("</span> + message + <span class="string">") was received."</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">  </span><br><span class="line">          <span class="keyword">switch</span> (message.getType()) &#123;  </span><br><span class="line">          <span class="keyword">case</span> ClusterNotification.FLUSH_KEY:  </span><br><span class="line">            cache.flushEntry((String) message.getData(), CLUSTER_ORIGIN);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> ClusterNotification.FLUSH_GROUP:  </span><br><span class="line">            cache.flushGroup((String) message.getData(), CLUSTER_ORIGIN);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> ClusterNotification.FLUSH_PATTERN:  </span><br><span class="line">            cache.flushPattern((String) message.getData(), CLUSTER_ORIGIN);  </span><br><span class="line">            <span class="keyword">break</span>;  </span><br><span class="line">        <span class="keyword">case</span> ClusterNotification.FLUSH_CACHE:  </span><br><span class="line">            cache.flushAll((Date) message.getData(), CLUSTER_ORIGIN);  </span><br><span class="line">            <span class="keyword">break</span>;      </span><br><span class="line">          <span class="keyword">case</span> CacheConstants.CLUSTER_ENTRY_ADD:  </span><br><span class="line">               log.info(<span class="string">"Cluster data add ("</span> + message + <span class="string">") "</span>);  </span><br><span class="line">               <span class="keyword">if</span> (message.getData() <span class="keyword">instanceof</span> SerialCacheEvent ) &#123;  </span><br><span class="line">                    SerialCacheEvent event = (SerialCacheEvent ) message.getData();  </span><br><span class="line">                    cache.putInCache(event.getKey(), event.getEntry().getContent(),setToArray(event.getEntry().getGroups()), <span class="keyword">null</span>, CLUSTER_ORIGIN);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">break</span>;  </span><br><span class="line">          <span class="keyword">case</span> CacheConstants.CLUSTER_ENTRY_UPDATE:  </span><br><span class="line">               log.info(<span class="string">"Cluster data update ("</span> + message + <span class="string">") "</span>);  </span><br><span class="line">               <span class="keyword">if</span> (message.getData() <span class="keyword">instanceof</span> SerialCacheEvent ) &#123;  </span><br><span class="line">                    SerialCacheEvent event = (SerialCacheEvent ) message.getData();  </span><br><span class="line">                    cache.putInCache(event.getKey(), event.getEntry().getContent(),setToArray(event.getEntry().getGroups()), <span class="keyword">null</span>, CLUSTER_ORIGIN);  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">break</span>;  </span><br><span class="line">          <span class="keyword">case</span> CacheConstants.CLUSTER_ENTRY_DELETE:  </span><br><span class="line">               log.info(<span class="string">"Cluster data delete ("</span> + message + <span class="string">") "</span>);  </span><br><span class="line">               <span class="keyword">if</span> (message.getData() <span class="keyword">instanceof</span> SerialCacheEvent ) &#123;  </span><br><span class="line">                    SerialCacheEvent event = (SerialCacheEvent ) message.getData();  </span><br><span class="line">                    cache.removeEntry(event.getKey());  </span><br><span class="line">               &#125;  </span><br><span class="line">               <span class="keyword">break</span>;  </span><br><span class="line">          <span class="keyword">default</span>:  </span><br><span class="line">               log.error(<span class="string">"The cluster notification ("</span> + message  </span><br><span class="line">                         + <span class="string">") is of an unknown type. Notification ignored."</span>);  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheEntryAdded</span><span class="params">(CacheEntryEvent event)</span> </span>&#123;  </span><br><span class="line">          log.info(<span class="string">"attribute data add ("</span> + event.getKey() + <span class="string">") "</span>);  </span><br><span class="line">          <span class="keyword">super</span>.cacheEntryAdded(event);  </span><br><span class="line">          <span class="keyword">if</span> (!CLUSTER_ORIGIN.equals(event.getOrigin())) &#123;  </span><br><span class="line">               sendNotification(<span class="keyword">new</span> ClusterNotification(  </span><br><span class="line">                         CacheConstants.CLUSTER_ENTRY_ADD, <span class="keyword">new</span> SerialCacheEvent (  </span><br><span class="line">                                   event.getMap(), event.getEntry(), CLUSTER_ORIGIN)));  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheEntryRemoved</span><span class="params">(CacheEntryEvent event)</span> </span>&#123;  </span><br><span class="line">          log.info(<span class="string">"attribute data delete ("</span> + event.getKey() + <span class="string">") "</span>);  </span><br><span class="line">          <span class="keyword">super</span>.cacheEntryRemoved(event);  </span><br><span class="line">          <span class="keyword">if</span> (!CLUSTER_ORIGIN.equals(event.getOrigin())) &#123;  </span><br><span class="line">               sendNotification(<span class="keyword">new</span> ClusterNotification(  </span><br><span class="line">                         CacheConstants.CLUSTER_ENTRY_DELETE, <span class="keyword">new</span> SerialCacheEvent (  </span><br><span class="line">                                   event.getMap(), event.getEntry(), CLUSTER_ORIGIN)));  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">     <span class="meta">@Override</span>  </span><br><span class="line">     <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">cacheEntryUpdated</span><span class="params">(CacheEntryEvent event)</span> </span>&#123;  </span><br><span class="line">          log.info(<span class="string">"attribute data update ("</span> + event.getKey() + <span class="string">") "</span>);  </span><br><span class="line">          <span class="keyword">super</span>.cacheEntryUpdated(event);  </span><br><span class="line">          <span class="keyword">if</span> (!CLUSTER_ORIGIN.equals(event.getOrigin())) &#123;  </span><br><span class="line">               sendNotification(<span class="keyword">new</span> ClusterNotification(  </span><br><span class="line">                         CacheConstants.CLUSTER_ENTRY_UPDATE, <span class="keyword">new</span> SerialCacheEvent (  </span><br><span class="line">                                   event.getMap(), event.getEntry(), CLUSTER_ORIGIN)));  </span><br><span class="line">          &#125;  </span><br><span class="line">     &#125;  </span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">     <span class="keyword">private</span> String[] setToArray(Set set)&#123;  </span><br><span class="line">          String[] strArray = <span class="keyword">new</span> String[set.size()];  </span><br><span class="line">           </span><br><span class="line">          <span class="keyword">int</span> i = <span class="number">0</span>;  </span><br><span class="line">          <span class="keyword">for</span>(Object str : set)&#123;  </span><br><span class="line">               strArray[i] = (String) str;  </span><br><span class="line">               i++;  </span><br><span class="line">          &#125;  </span><br><span class="line">          <span class="keyword">return</span> strArray;  </span><br><span class="line">     &#125;  </span><br><span class="line">  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>CacheConstants </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> FLUSH_PATTERN = <span class="number">3</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 刷新缓存对象</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> FLUSH_CACHE = <span class="number">4</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 集群entry add处理</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLUSTER_ENTRY_ADD = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 集群entry update处理</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLUSTER_ENTRY_UPDATE = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * 集群entry delete处理</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="keyword">int</span> CLUSTER_ENTRY_DELETE = <span class="number">22</span>;</span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>SerialCacheEvent </p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> java.io.Serializable;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.oscache.base.Cache;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.oscache.base.CacheEntry;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SerialCacheEvent</span>  <span class="keyword">implements</span> <span class="title">Serializable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">649226025117113267L</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The cache where the entry resides.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> Cache map = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * The entry that the event applies to.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="keyword">private</span> CacheEntry entry = <span class="keyword">null</span>;</span><br><span class="line">      </span><br><span class="line">      <span class="keyword">private</span> String origin = <span class="keyword">null</span>;</span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Constructs a cache entry event object with no specified origin</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">       *            The cache map of the cache entry</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">       *            The cache entry that the event applies to</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span>  <span class="title">SerialCacheEvent</span>  <span class="params">(Cache map, CacheEntry entry)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>( map, entry, <span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Constructs a cache entry event object</span></span><br><span class="line"><span class="comment">       *</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> map</span></span><br><span class="line"><span class="comment">       *            The cache map of the cache entry</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> entry</span></span><br><span class="line"><span class="comment">       *            The cache entry that the event applies to</span></span><br><span class="line"><span class="comment">       * <span class="doctag">@param</span> origin</span></span><br><span class="line"><span class="comment">       *            The origin of this event</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span>  <span class="title">SerialCacheEvent</span>  <span class="params">(Cache map, CacheEntry entry, String origin)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>. map = map;</span><br><span class="line">             <span class="keyword">this</span>. entry = entry;</span><br><span class="line">             <span class="keyword">this</span>. origin = origin;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Retrieve the cache entry that the event applies to.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> CacheEntry <span class="title">getEntry</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> entry;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Retrieve the cache entry key</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getKey</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> entry.getKey();</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">/**</span></span><br><span class="line"><span class="comment">       * Retrieve the cache map where the entry resides.</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> Cache <span class="title">getMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> map;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> String <span class="title">getOrigin</span><span class="params">()</span> </span>&#123;</span><br><span class="line">             <span class="keyword">return</span> origin;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setOrigin</span><span class="params">(String origin)</span> </span>&#123;</span><br><span class="line">             <span class="keyword">this</span>. origin = origin;</span><br><span class="line">      &#125;</span><br><span class="line">      </span><br><span class="line">      </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h1 id="遗留问题"><a href="#遗留问题" class="headerlink" title="遗留问题"></a>遗留问题</h1><p>1. OSCache：已停止更新，集群方面存在问题（集群规模不能太大等），是否可以考虑使用其他缓存框架。<br>2. JGroups：目前使用的JGroups版本较低，其中一些类已经废弃。高版本有更优、更稳定的性能，是否有必要根据高版本JGroups重写JavaGroupsBroadcastingListener还需要考量。如果想引入其他通信框架，重写JavaGroupsBroadcastingListener即可。</p><h1 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h1><ol><li><a href="http://blog.csdn.net/laven90/article/details/9567499" target="_blank" rel="noopener">oscache分布式缓存</a>JavaGroupsBroadcastingListenerImpl源码存在错误，修改见本文JavaGroupsSyncBroadcastingListener</li><li><a href="http://3001448.blog.51cto.com/2991448/1202879" target="_blank" rel="noopener">Oscache分布式集群配置总结</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Technology </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Cache </tag>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
